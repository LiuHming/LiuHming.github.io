{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/ocean/source/404.html","path":"404.html","modified":0,"renderable":1},{"_id":"themes/ocean/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"themes/ocean/source/css/404.styl","path":"css/404.styl","modified":0,"renderable":1},{"_id":"themes/ocean/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/ocean/source/fancybox/jquery.fancybox.min.css","path":"fancybox/jquery.fancybox.min.css","modified":0,"renderable":1},{"_id":"themes/ocean/source/fancybox/jquery.fancybox.min.js","path":"fancybox/jquery.fancybox.min.js","modified":0,"renderable":1},{"_id":"themes/ocean/source/images/forrestgump.png","path":"images/forrestgump.png","modified":0,"renderable":1},{"_id":"themes/ocean/source/images/hexo-inverted.svg","path":"images/hexo-inverted.svg","modified":0,"renderable":1},{"_id":"themes/ocean/source/js/busuanzi-2.3.pure.min.js","path":"js/busuanzi-2.3.pure.min.js","modified":0,"renderable":1},{"_id":"themes/ocean/source/js/jquery-2.0.3.min.js","path":"js/jquery-2.0.3.min.js","modified":0,"renderable":1},{"_id":"themes/ocean/source/images/hexo.svg","path":"images/hexo.svg","modified":0,"renderable":1},{"_id":"themes/ocean/source/js/jquery.justifiedGallery.min.js","path":"js/jquery.justifiedGallery.min.js","modified":0,"renderable":1},{"_id":"themes/ocean/source/js/ocean.js","path":"js/ocean.js","modified":0,"renderable":1},{"_id":"themes/ocean/source/js/pace.min.js","path":"js/pace.min.js","modified":0,"renderable":1},{"_id":"themes/ocean/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/ocean/source/js/lazyload.min.js","path":"js/lazyload.min.js","modified":0,"renderable":1},{"_id":"themes/ocean/source/js/tocbot.min.js","path":"js/tocbot.min.js","modified":0,"renderable":1},{"_id":"themes/ocean/source/css/feathericon/feathericon.eot","path":"css/feathericon/feathericon.eot","modified":0,"renderable":1},{"_id":"themes/ocean/source/css/feathericon/feathericon.svg","path":"css/feathericon/feathericon.svg","modified":0,"renderable":1},{"_id":"themes/ocean/source/css/feathericon/feathericon.ttf","path":"css/feathericon/feathericon.ttf","modified":0,"renderable":1},{"_id":"themes/ocean/source/css/feathericon/feathericon.woff","path":"css/feathericon/feathericon.woff","modified":0,"renderable":1},{"_id":"themes/ocean/source/css/feathericon/feathericon.woff2","path":"css/feathericon/feathericon.woff2","modified":0,"renderable":1},{"_id":"themes/ocean/source/fonts/raleway_medium/Raleway-Medium.svg","path":"fonts/raleway_medium/Raleway-Medium.svg","modified":0,"renderable":1},{"_id":"themes/ocean/source/fonts/raleway_medium/Raleway-Medium.eot","path":"fonts/raleway_medium/Raleway-Medium.eot","modified":0,"renderable":1},{"_id":"themes/ocean/source/fonts/raleway_medium/Raleway-Medium.ttf","path":"fonts/raleway_medium/Raleway-Medium.ttf","modified":0,"renderable":1},{"_id":"themes/ocean/source/fonts/raleway_medium/Raleway-Medium.woff","path":"fonts/raleway_medium/Raleway-Medium.woff","modified":0,"renderable":1},{"_id":"themes/ocean/source/images/ocean/ocean.mp4","path":"images/ocean/ocean.mp4","modified":0,"renderable":1},{"_id":"themes/ocean/source/images/ocean/ocean.png","path":"images/ocean/ocean.png","modified":0,"renderable":1},{"_id":"themes/ocean/source/images/ocean/ocean.ogv","path":"images/ocean/ocean.ogv","modified":0,"renderable":1},{"_id":"themes/ocean/source/images/ocean/ocean.webm","path":"images/ocean/ocean.webm","modified":0,"renderable":1},{"_id":"themes/ocean/source/images/ocean/overlay-hero.png","path":"images/ocean/overlay-hero.png","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"acdefbcebd67674d27177f73fb4d9b1c76d63b09","modified":1653463921022},{"_id":"source/_posts/interview.md","hash":"e2a7e68c334a28144689f3cf0f80d270d8616b16","modified":1653794271081},{"_id":"source/categories/index.md","hash":"019d7bb9a52b0b7943dfa0b0de8ed25ef8518b3a","modified":1652946051120},{"_id":"source/about/index.md","hash":"602f2d0201184222be15b3d3ff464458574a06e2","modified":1652946051120},{"_id":"source/gallery/index.md","hash":"97d6d5abb5bf5d3969eb8b195c831bc203f1da48","modified":1652946051121},{"_id":"themes/ocean/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1648100291000},{"_id":"themes/ocean/.gitignore","hash":"ff40c2a79f163fe79ff790b3a230e372903171ac","modified":1653103427797},{"_id":"themes/ocean/LICENSE","hash":"7df059597099bb7dcf25d2a9aedfaf4465f72d8d","modified":1631775936000},{"_id":"themes/ocean/README.md","hash":"28876fb36a83896ba0d54923b2ef17c2f9f183bf","modified":1631775936000},{"_id":"themes/ocean/_config.yml","hash":"9aafd1cb53fa1d8a6949481fcaa7c2e4b36ed5f0","modified":1648100291000},{"_id":"themes/ocean/package.json","hash":"b993176f8c35bc3ab9dbd8642ec6cd125fcb447e","modified":1631775937000},{"_id":"themes/ocean/.idea/modules.xml","hash":"38399315bb4aeb57290754fdd72a5c914def183c","modified":1648100289000},{"_id":"themes/ocean/.idea/ocean.iml","hash":"6c84deda8dfa479a1473d2a6bb8886b03dbd4551","modified":1648100289000},{"_id":"themes/ocean/.idea/vcs.xml","hash":"c92f3eb0ad1c70371e177a4d7d741f90af3f902c","modified":1648100289000},{"_id":"themes/ocean/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1631775936000},{"_id":"themes/ocean/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1631775936000},{"_id":"themes/ocean/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1631775936000},{"_id":"themes/ocean/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1631775936000},{"_id":"themes/ocean/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1631775936000},{"_id":"themes/ocean/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1631775936000},{"_id":"themes/ocean/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1631775936000},{"_id":"themes/ocean/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1631775936000},{"_id":"themes/ocean/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1631775936000},{"_id":"themes/ocean/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1631775936000},{"_id":"themes/ocean/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1631775936000},{"_id":"themes/ocean/languages/zh-CN.yml","hash":"746f310e3d6d6ec80352bd620eceeeb5e99b37cc","modified":1648100291000},{"_id":"themes/ocean/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1631775937000},{"_id":"themes/ocean/layout/categories.ejs","hash":"bf3eff3f238a9798227ce868f5c08b230f66ea04","modified":1631775937000},{"_id":"themes/ocean/layout/index.ejs","hash":"1c3e5237d2c02c0dd2b95fad282603bb76d70c23","modified":1631775937000},{"_id":"themes/ocean/layout/layout.ejs","hash":"a0648569b4e28464559ad8efae9115d35e30fd28","modified":1631775937000},{"_id":"themes/ocean/layout/page.ejs","hash":"a9a48ae63f5d68a36382951166fdd6e482b901f1","modified":1631775937000},{"_id":"themes/ocean/layout/post.ejs","hash":"a9a48ae63f5d68a36382951166fdd6e482b901f1","modified":1631775937000},{"_id":"themes/ocean/layout/tags.ejs","hash":"1da22539946ecb8cf8f9fa08351271196d548b19","modified":1631775937000},{"_id":"themes/ocean/source/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1648100291000},{"_id":"themes/ocean/source/404.html","hash":"788929fab7b99dd74575399f41cddae6f63ce1f4","modified":1631775937000},{"_id":"themes/ocean/source/favicon.ico","hash":"d125a7c3f6f2c75e3f3fb7df9ef28db2987a85a7","modified":1648100291000},{"_id":"themes/ocean/layout/_partial/after-footer.ejs","hash":"e6a4d823a84579a1a4fdc69a6583f33b1045ef8d","modified":1648100291000},{"_id":"themes/ocean/layout/_partial/archive.ejs","hash":"c3bb015d3f368cf63ba51779ba849dd263654f23","modified":1631775936000},{"_id":"themes/ocean/layout/_partial/archive-post.ejs","hash":"d6fe55a0720c5a3e0bb07d9f79b9a7c661e24777","modified":1648100291000},{"_id":"themes/ocean/layout/_partial/article.ejs","hash":"250e90790f720c505c4fcfb105225f11567abf1d","modified":1648100291000},{"_id":"themes/ocean/layout/_partial/footer.ejs","hash":"8f45c8f501bf1d28ff5b101940191fd9c1aa374a","modified":1631775936000},{"_id":"themes/ocean/layout/_partial/head.ejs","hash":"a3e967e14f29fbbffafcfa112ffd0f081e5faf6a","modified":1648100291000},{"_id":"themes/ocean/layout/_partial/ocean.ejs","hash":"f8cc4e4f9df1832b8ab6d7033840c57f3ad14fad","modified":1631775936000},{"_id":"themes/ocean/layout/_partial/sidebar.ejs","hash":"e7e40dba2eadf0c2d2a5c75c58c6f78234a039a4","modified":1631775937000},{"_id":"themes/ocean/layout/_partial/totop.ejs","hash":"72b960315983ee95363fa9cabe82f52916ac9ae3","modified":1631775937000},{"_id":"themes/ocean/source/css/404.styl","hash":"14b2fec2da86081f0545732552aa5f07b545c19a","modified":1631775937000},{"_id":"themes/ocean/source/css/_extend.styl","hash":"e0a1d50bd4c3fb219fd585adc34464e9a1dd2dd9","modified":1648100291000},{"_id":"themes/ocean/source/css/_feathericon.styl","hash":"4c7427906a608343397afefbffe75722a7d04278","modified":1648100291000},{"_id":"themes/ocean/source/css/_mixins.styl","hash":"6959409df2dd0a1ca05be0c0e9b2a884efdfb82d","modified":1631775937000},{"_id":"themes/ocean/source/css/_fonts.styl","hash":"4fb2e8660548f2cb3abcd44a204c1bc627f1fadf","modified":1648100291000},{"_id":"themes/ocean/source/css/_normalize.styl","hash":"b3337320133b7a336db7033aa6bbe94b054c0b21","modified":1631775937000},{"_id":"themes/ocean/source/css/_variables.styl","hash":"ed2e95e9a2e753f9c0cfce0940e377e889b996a9","modified":1648100291000},{"_id":"themes/ocean/source/css/style.styl","hash":"0b1bdaa6a89d880e655801ca79ccfe35a12bcc96","modified":1648100291000},{"_id":"themes/ocean/source/fancybox/jquery.fancybox.min.css","hash":"2e6a66987dbc7a57bbfd2655bce166739b4ba426","modified":1631775937000},{"_id":"themes/ocean/source/images/hexo-inverted.svg","hash":"525309ea3c7360f83d1d9df6d04c256d7171950d","modified":1631775937000},{"_id":"themes/ocean/source/js/busuanzi-2.3.pure.min.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1631775937000},{"_id":"themes/ocean/source/images/hexo.svg","hash":"71e7204d04ccfe260f06ea5873484791cd5f404a","modified":1631775937000},{"_id":"themes/ocean/source/js/jquery.justifiedGallery.min.js","hash":"73b9373cd80bdbf77e711818095f3f120a019547","modified":1631775937000},{"_id":"themes/ocean/source/js/ocean.js","hash":"39f7f028a6c449b3e418e659abba7276cff7f3b0","modified":1631775937000},{"_id":"themes/ocean/source/js/pace.min.js","hash":"d32ab818e0f97d3b0c80f5631fc23d8a0cb52795","modified":1631775937000},{"_id":"themes/ocean/source/js/search.js","hash":"3e66ea259eff66e36e240b695c4753c5d4454bbb","modified":1631775937000},{"_id":"themes/ocean/source/js/lazyload.min.js","hash":"b801b3946fb9b72e03512c0663458e140e1fa77b","modified":1631775937000},{"_id":"themes/ocean/source/js/tocbot.min.js","hash":"bc45d3586a21f7e364cd6efe58844932c00cf11c","modified":1648100291000},{"_id":"themes/ocean/layout/_partial/post/albums.ejs","hash":"a7b0c7059ec6ce0c0d4fabdece662e0ebe5f85b9","modified":1631775937000},{"_id":"themes/ocean/layout/_partial/post/busuanzi.ejs","hash":"8db57f869ba5810a83e47395e51df50f59a6bcb2","modified":1631775937000},{"_id":"themes/ocean/layout/_partial/post/category.ejs","hash":"386f47b0299351f45cac2ad43779893b31f60c28","modified":1631775937000},{"_id":"themes/ocean/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1631775937000},{"_id":"themes/ocean/layout/_partial/post/gallery.ejs","hash":"ff0279081ba55c1fbe6d7029cc15f197b0c503fd","modified":1631775937000},{"_id":"themes/ocean/layout/_partial/post/gitalk.ejs","hash":"1bbb92e9c571de1f539120ad5519b91c8a02c709","modified":1631775937000},{"_id":"themes/ocean/layout/_partial/post/justifiedGallery.ejs","hash":"db321fe1cd5965d9303a25aeff5349798a1b7865","modified":1631775937000},{"_id":"themes/ocean/layout/_partial/post/nav.ejs","hash":"c997e2f8f93a13f8684b46dcef1bbb052349d1c7","modified":1631775937000},{"_id":"themes/ocean/layout/_partial/post/search.ejs","hash":"2c9d19d1685e834aa2020998da2a2d259ce9b9ff","modified":1631775937000},{"_id":"themes/ocean/layout/_partial/post/tag.ejs","hash":"adaea79d14202c281d457a2cb4ee766d023c4088","modified":1631775937000},{"_id":"themes/ocean/layout/_partial/post/title.ejs","hash":"fb72872142ee3a9e68f763d2c5d49b601aa0e6ad","modified":1631775937000},{"_id":"themes/ocean/layout/_partial/post/tocbot.ejs","hash":"11ddd6106103c3b4506f69da8b6d4b8f20c95c89","modified":1631775937000},{"_id":"themes/ocean/layout/_partial/post/topping.ejs","hash":"7a839e91c502cf4c188b8c10f4f02675dbc5cde5","modified":1631775937000},{"_id":"themes/ocean/layout/_partial/post/valine.ejs","hash":"cde2408a3e1615d1899e6e89e8d2ccbecef1d7d7","modified":1631775937000},{"_id":"themes/ocean/source/css/_partial/albums.styl","hash":"0659d5f7469f24a415354ff767d949926465d515","modified":1631775937000},{"_id":"themes/ocean/source/css/_partial/apple.styl","hash":"e06dce604cc58ec39d677e4e59910c2725684901","modified":1631775937000},{"_id":"themes/ocean/source/css/_partial/article.styl","hash":"fd622afc9ae00d5c75522d1f5acc0daca580efbb","modified":1648100291000},{"_id":"themes/ocean/source/css/_partial/archive.styl","hash":"1b0e09e6709c9489ef993fafc4b4952414de5999","modified":1631775937000},{"_id":"themes/ocean/source/css/_partial/articles.styl","hash":"7bf289013d304505984b251be725b49165a694fd","modified":1631775937000},{"_id":"themes/ocean/source/css/_partial/blockquote.styl","hash":"6c6f24b51366ced1cf13027c05957eeefe1eeada","modified":1648100291000},{"_id":"themes/ocean/source/css/_partial/categories.styl","hash":"f0c898823a5ddc37ae6bf76cc34ce8e50dd30885","modified":1631775937000},{"_id":"themes/ocean/source/css/_partial/english.styl","hash":"32ebfa9f9c103c495064d288418088234e940586","modified":1648100291000},{"_id":"themes/ocean/source/css/_partial/footer.styl","hash":"24779cbce1012d4f35ffc6b3ec0830cbc2ea3b3f","modified":1631775937000},{"_id":"themes/ocean/source/css/_partial/float.styl","hash":"d888df89a172e4c8119cb8740fc1eae1a9539157","modified":1631775937000},{"_id":"themes/ocean/source/css/_partial/gallery.styl","hash":"7bdc2c9fb4971dbd7511c5cbb69bd611f20db591","modified":1631775937000},{"_id":"themes/ocean/source/css/_partial/gitalk.styl","hash":"3706eef2e0541493f1679a30241d279e29dfdc17","modified":1631775937000},{"_id":"themes/ocean/source/css/_partial/highlight.styl","hash":"c6e99fd23056fb01177aeefbc5dd4a8e88cf8f81","modified":1631775937000},{"_id":"themes/ocean/source/css/_partial/justifiedGallery.styl","hash":"e7b5784ffd501f98216a717f876f2adb23fa5cd9","modified":1631775937000},{"_id":"themes/ocean/source/css/_partial/layou.styl","hash":"96ce86604f0f0977e4bf404d802ba1904648571b","modified":1648100291000},{"_id":"themes/ocean/source/css/_partial/lists.styl","hash":"6fd213c53027d42164bfc9f0e3b4ea02317bfb89","modified":1631775937000},{"_id":"themes/ocean/source/css/_partial/mobile.styl","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1631775937000},{"_id":"themes/ocean/source/css/_partial/navbar.styl","hash":"14a40bc96a4c566abd197013e46341b9edffc5ec","modified":1648100474000},{"_id":"themes/ocean/source/css/_partial/ocean.styl","hash":"69ba351909c73eb1e04510facc9b35dd584198e0","modified":1631775937000},{"_id":"themes/ocean/source/css/_partial/pace.styl","hash":"e326918ba276ee332d0598d8193ccd8353e7d916","modified":1631775937000},{"_id":"themes/ocean/source/css/_partial/sidebar.styl","hash":"600c70f1de82da5223af290d47a583f9c379d188","modified":1631775937000},{"_id":"themes/ocean/source/css/_partial/search.styl","hash":"011aaf21942dfff514ed4e98ce20142efbdd1b71","modified":1631775937000},{"_id":"themes/ocean/source/css/_partial/tag.styl","hash":"925af8beede44ab53fe3cd0a5c472d2baa03baec","modified":1631775937000},{"_id":"themes/ocean/source/css/_partial/tocbot.styl","hash":"da8560a8f9718d3afb9760956f9f8e4bb88b3dd8","modified":1631775937000},{"_id":"themes/ocean/source/css/feathericon/feathericon.eot","hash":"e2a01ae6f849841bc7a9fd21e5b7b450f1ded19b","modified":1631775937000},{"_id":"themes/ocean/source/css/_partial/totop.styl","hash":"4bae031b6852384666cdf36e98c6bbbba1281453","modified":1631775937000},{"_id":"themes/ocean/source/css/_partial/valine.styl","hash":"b980d02c0d1aad4866c8173c20f5e6b53026cbd5","modified":1631775937000},{"_id":"themes/ocean/source/css/feathericon/feathericon.ttf","hash":"d0d80c3c960d7d45e6bd7fa428d8a6a8c8245b2d","modified":1631775937000},{"_id":"themes/ocean/source/css/feathericon/feathericon.woff","hash":"d22fe861e47afd92969ab46c7cbb7ea9c225aaf8","modified":1631775937000},{"_id":"themes/ocean/source/css/feathericon/feathericon.woff2","hash":"2c11c45331d914ee38ad42ccf966132a508b5596","modified":1631775937000},{"_id":"themes/ocean/source/fonts/raleway_medium/Raleway-Medium.svg","hash":"b0a3535723b40ad2fa1636b244099af1c86c71a7","modified":1648100291000},{"_id":"themes/ocean/source/fonts/raleway_medium/Raleway-Medium.eot","hash":"532e7f0e62bcc9be2fb72c143635fa5051503414","modified":1648100291000},{"_id":"themes/ocean/source/fonts/raleway_medium/Raleway-Medium.ttf","hash":"1133580bee441a8ad24fb2dde3bbdc324d8648af","modified":1648100291000},{"_id":"themes/ocean/source/fonts/raleway_medium/Raleway-Medium.woff","hash":"83f9d80f2e2a158f7e3024289d8cd856d0966efb","modified":1648100291000},{"_id":"themes/ocean/source/images/ocean/overlay-hero.png","hash":"92481a1848c35be96a693af11f77265323a7c189","modified":1631775937000},{"_id":"themes/ocean/source/fancybox/jquery.fancybox.min.js","hash":"600c86071c2b5198cfa2c052dd90b78920f62b45","modified":1631775937000},{"_id":"themes/ocean/source/js/jquery-2.0.3.min.js","hash":"ab131f0b13a89f24543fadbf496b1c813d417c02","modified":1631775937000},{"_id":"themes/ocean/source/css/feathericon/feathericon.svg","hash":"c113006c6822451802c8457128c352c0e4934453","modified":1631775937000},{"_id":"themes/ocean/screenshots/hexo-theme-ocean.jpg","hash":"13b5045d2120cac2f68849757f5e0af08938b7c6","modified":1631775937000},{"_id":"themes/ocean/.idea/workspace.xml","hash":"50fc7ffced8e353f59bdd6565a01ef6659063298","modified":1648100556000},{"_id":"themes/ocean/source/images/forrestgump.png","hash":"18ad6a8ba815878e36a0d5562136dc4fb8920c12","modified":1631775937000},{"_id":"themes/ocean/source/images/ocean/ocean.ogv","hash":"9c6b5d6b0544472cee39f5eafac2d5cbba5fd86b","modified":1631775937000},{"_id":"themes/ocean/source/images/ocean/ocean.png","hash":"8245d07f812625d19b48ad2d00f8191f2aa4d304","modified":1631775937000},{"_id":"themes/ocean/source/images/ocean/ocean.webm","hash":"65aa2b6483e0151611899e31571057334c60d9e4","modified":1631775937000},{"_id":"themes/ocean/source/images/ocean/ocean.mp4","hash":"1e89cac2d652005d9dafd3ecb4dd460a8ff6d6af","modified":1631775937000},{"_id":"public/atom.xml","hash":"702ea19af0469ffd6616b6468afebcad16d24277","modified":1653466540190},{"_id":"public/search.xml","hash":"f407c1a5c2feda5b49bedc0d2ca4522900a63b4c","modified":1653466540190},{"_id":"public/about/index.html","hash":"5eaaa6c8d21f8501113b647a7fc58fe2e5727c6f","modified":1653466540190},{"_id":"public/categories/index.html","hash":"5c5ed212d76548be70fc0032a56feae001f0a5cb","modified":1653466540190},{"_id":"public/gallery/index.html","hash":"69b5616ac893e5796db326b8c433a8a85066a546","modified":1653466540190},{"_id":"public/2022/05/24/interview/index.html","hash":"cece22d33a7a9700f002d73c3e7af30ef52412cc","modified":1653466540190},{"_id":"public/2022/05/19/hello-world/index.html","hash":"9f6a73bce6cd9306cd4e0d533b0c9cff0220536f","modified":1653466540190},{"_id":"public/archives/index.html","hash":"1e7c603db4bfa3e4838749d35e4123335d813aad","modified":1653466540190},{"_id":"public/archives/2022/index.html","hash":"31e97c993b9e7518af37a82948f8b1cdab3f369c","modified":1653466540190},{"_id":"public/archives/2022/05/index.html","hash":"0b500ccd898bd158740c0d2652b4b78d8e0cc0b8","modified":1653466540190},{"_id":"public/categories/Start/index.html","hash":"488f316cc32a3b350e171b4b4ca58fb83fdf7d11","modified":1653466540190},{"_id":"public/index.html","hash":"d4b1db5cf8fe22aacbb15aef7da3ed89eff7b664","modified":1653466540190},{"_id":"public/favicon.ico","hash":"d125a7c3f6f2c75e3f3fb7df9ef28db2987a85a7","modified":1653466540190},{"_id":"public/images/hexo-inverted.svg","hash":"525309ea3c7360f83d1d9df6d04c256d7171950d","modified":1653466540190},{"_id":"public/images/hexo.svg","hash":"71e7204d04ccfe260f06ea5873484791cd5f404a","modified":1653466540190},{"_id":"public/css/feathericon/feathericon.eot","hash":"e2a01ae6f849841bc7a9fd21e5b7b450f1ded19b","modified":1653466540190},{"_id":"public/css/feathericon/feathericon.ttf","hash":"d0d80c3c960d7d45e6bd7fa428d8a6a8c8245b2d","modified":1653466540190},{"_id":"public/css/feathericon/feathericon.woff","hash":"d22fe861e47afd92969ab46c7cbb7ea9c225aaf8","modified":1653466540190},{"_id":"public/css/feathericon/feathericon.woff2","hash":"2c11c45331d914ee38ad42ccf966132a508b5596","modified":1653466540190},{"_id":"public/fonts/raleway_medium/Raleway-Medium.svg","hash":"b0a3535723b40ad2fa1636b244099af1c86c71a7","modified":1653466540190},{"_id":"public/fonts/raleway_medium/Raleway-Medium.eot","hash":"532e7f0e62bcc9be2fb72c143635fa5051503414","modified":1653466540190},{"_id":"public/fonts/raleway_medium/Raleway-Medium.ttf","hash":"1133580bee441a8ad24fb2dde3bbdc324d8648af","modified":1653466540190},{"_id":"public/fonts/raleway_medium/Raleway-Medium.woff","hash":"83f9d80f2e2a158f7e3024289d8cd856d0966efb","modified":1653466540190},{"_id":"public/images/ocean/overlay-hero.png","hash":"92481a1848c35be96a693af11f77265323a7c189","modified":1653466540190},{"_id":"public/css/feathericon/feathericon.svg","hash":"c113006c6822451802c8457128c352c0e4934453","modified":1653466540190},{"_id":"public/404.html","hash":"788929fab7b99dd74575399f41cddae6f63ce1f4","modified":1653466540190},{"_id":"public/css/404.css","hash":"952f9d1b869886a2940768fb7d1fd891ccea29fa","modified":1653466540190},{"_id":"public/fancybox/jquery.fancybox.min.css","hash":"2e6a66987dbc7a57bbfd2655bce166739b4ba426","modified":1653466540190},{"_id":"public/js/busuanzi-2.3.pure.min.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1653466540190},{"_id":"public/js/ocean.js","hash":"39f7f028a6c449b3e418e659abba7276cff7f3b0","modified":1653466540190},{"_id":"public/js/pace.min.js","hash":"d32ab818e0f97d3b0c80f5631fc23d8a0cb52795","modified":1653466540190},{"_id":"public/js/search.js","hash":"3e66ea259eff66e36e240b695c4753c5d4454bbb","modified":1653466540190},{"_id":"public/js/lazyload.min.js","hash":"b801b3946fb9b72e03512c0663458e140e1fa77b","modified":1653466540190},{"_id":"public/js/tocbot.min.js","hash":"bc45d3586a21f7e364cd6efe58844932c00cf11c","modified":1653466540190},{"_id":"public/css/style.css","hash":"bcd4bdd6cae23d4a0981b76c9597e3d62ef45cbb","modified":1653466540190},{"_id":"public/js/jquery.justifiedGallery.min.js","hash":"73b9373cd80bdbf77e711818095f3f120a019547","modified":1653466540190},{"_id":"public/images/forrestgump.png","hash":"18ad6a8ba815878e36a0d5562136dc4fb8920c12","modified":1653466540190},{"_id":"public/fancybox/jquery.fancybox.min.js","hash":"600c86071c2b5198cfa2c052dd90b78920f62b45","modified":1653466540190},{"_id":"public/js/jquery-2.0.3.min.js","hash":"ab131f0b13a89f24543fadbf496b1c813d417c02","modified":1653466540190},{"_id":"public/images/ocean/ocean.ogv","hash":"9c6b5d6b0544472cee39f5eafac2d5cbba5fd86b","modified":1653466540190},{"_id":"public/images/ocean/ocean.png","hash":"8245d07f812625d19b48ad2d00f8191f2aa4d304","modified":1653466540190},{"_id":"public/images/ocean/ocean.webm","hash":"65aa2b6483e0151611899e31571057334c60d9e4","modified":1653466540190},{"_id":"public/images/ocean/ocean.mp4","hash":"1e89cac2d652005d9dafd3ecb4dd460a8ff6d6af","modified":1653466540190}],"Category":[{"name":"Start","_id":"cl3lbac1z0003rgtqfln4fqrf"}],"Data":[],"Page":[{"title":"关于","date":"2021-09-16T09:37:43.000Z","_content":"\n## 浪淘沙\n\n翠柳戏炊烟  \n莠草疏栏   \n桃源别有一片天   \n解剑放舟清波上  \n随遇而安  \n\n鸳鸯不羡仙  \n今夕何年  \n人生有酒需尽欢  \n醉卧红尘最深处  \n遥望千山 \n","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2021-09-16 17:37:43\n---\n\n## 浪淘沙\n\n翠柳戏炊烟  \n莠草疏栏   \n桃源别有一片天   \n解剑放舟清波上  \n随遇而安  \n\n鸳鸯不羡仙  \n今夕何年  \n人生有酒需尽欢  \n醉卧红尘最深处  \n遥望千山 \n","updated":"2022-05-19T07:40:51.120Z","path":"about/index.html","comments":1,"layout":"page","_id":"cl3lbac1r0000rgtq7wpu2u9z","content":"<h2 id=\"浪淘沙\"><a href=\"#浪淘沙\" class=\"headerlink\" title=\"浪淘沙\"></a>浪淘沙</h2><p>翠柳戏炊烟<br>莠草疏栏<br>桃源别有一片天<br>解剑放舟清波上<br>随遇而安  </p>\n<p>鸳鸯不羡仙<br>今夕何年<br>人生有酒需尽欢<br>醉卧红尘最深处<br>遥望千山 </p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"浪淘沙\"><a href=\"#浪淘沙\" class=\"headerlink\" title=\"浪淘沙\"></a>浪淘沙</h2><p>翠柳戏炊烟<br>莠草疏栏<br>桃源别有一片天<br>解剑放舟清波上<br>随遇而安  </p>\n<p>鸳鸯不羡仙<br>今夕何年<br>人生有酒需尽欢<br>醉卧红尘最深处<br>遥望千山 </p>\n"},{"title":"归档","date":"2021-09-17T02:41:43.000Z","type":"categories","layout":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 归档\ndate: 2021-09-17 10:41:43\ntype: categories\nlayout: categories\n---\n","updated":"2022-05-19T07:40:51.120Z","path":"categories/index.html","comments":1,"_id":"cl3lbac1y0002rgtqf13kd4xo","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"相册","date":"2021-09-16T09:40:42.000Z","_content":"","source":"gallery/index.md","raw":"---\ntitle: 相册\ndate: 2021-09-16 17:40:42\n---\n","updated":"2022-05-19T07:40:51.121Z","path":"gallery/index.html","comments":1,"layout":"page","_id":"cl3lbac200004rgtq7qey2l0t","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Hello World","_content":"第一份工作为青岛日日顺乐家物联科 主要负责多个app维护和功能开发\n\napp都是通过webview与H5页面混合开发，最后通过多渠道包方式进行不同app的打包\n\n消息语音播报、H5更新包断点续传下载、短视频录制、直播功能模块等开发\n\n第二份工作是杭州登虹科技，主要负责部门慧视互联app及其使用的SDK相关维护开发，主要开发语言是java/kotlin/reactnative，还有部分H5页面开发\n\n多门店巡店 自定义支持单双列切换搭载playerview的list、直播效果编辑模块、自定义开发通用树组件、sdk支持动态域名等功能的开发\n\nandroid js 交互\n\njs调用Android\n\n* 创建一个处理交互的方法类，在方法上面添加@JavascriptInterface，再执行webview.addJavascriptinterface()进行映射。\n* 通过 `WebViewClient`的shouldoverrideUrl()进行链接拦截处理\n* 通过 `WebChromeClient`的onjsaler confirm prompt\n\nandroid 调用 js\n\n* webview.loadurl（“`javascript:`”）\n* `WebView.evaluateJavascript(`)\n\nwebview优化\n\n1.独立进程，android：process 退出system。exit\n\n2.预加载 建立webview维护类。使用mutablecontextwrapper 优先传入applicationcontext，后面可以通过重新设置basecontext更改绑定特定的activity\n\n多渠道包：productflavor配置不同applicationid，将公有库统一维护，各自业务使用风味名+implement进行引用，一些第三方库的一些秘钥使用manifestplaceholder进行维护\n\nintentservice是继承service来创建工作线程，内部原理是在oncreate的时候创建一个handlerthread和他的servicehandler，在onstartcommand里面会点用onstart进行message的发送，在连续进行任务时可以按顺序进行处理。在任务都处理完成之后会自动结束。\n\nhandlerthread： 本身是thread  在run方法中创建当前子线程looper，提供一个getlooper，加了同步锁 对象锁，\n\n1. 单一职责(Single Responsibility Principle)：一个类只做一件事，可读性提高\n2. 里式替换原则( Liskov Substitution Principle):依赖继承和多态，就是能用父类的地方就可以用子类替换，用子类的但不能用父类。\n3. 依赖倒置原则(Dependence Inversion Principle)：依赖抽象，就是模块之间的依赖通过抽象发生。\n4. 开闭原则(Open-Close Principle):不管是实体类,模块还是函数都应该遵循对扩展开放对修改关闭。还是要依赖封装和继承\n5. 接口隔离原则(Interface Segregation Principle):一个类对另一个类的依赖应该建立在最小的接口上，如果接口太大，我们需要把它分割成一些更细小的接口，也是为了降低耦合性\n6. 迪米特原则(Law of Demeter ):也称最少知识原则，也就是说一个类应该对自己需要耦合或者调用的类知道的最少，只需知道该方法即可，实现细节不必知道。\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ncategories:\n- Start\n---\n第一份工作为青岛日日顺乐家物联科 主要负责多个app维护和功能开发\n\napp都是通过webview与H5页面混合开发，最后通过多渠道包方式进行不同app的打包\n\n消息语音播报、H5更新包断点续传下载、短视频录制、直播功能模块等开发\n\n第二份工作是杭州登虹科技，主要负责部门慧视互联app及其使用的SDK相关维护开发，主要开发语言是java/kotlin/reactnative，还有部分H5页面开发\n\n多门店巡店 自定义支持单双列切换搭载playerview的list、直播效果编辑模块、自定义开发通用树组件、sdk支持动态域名等功能的开发\n\nandroid js 交互\n\njs调用Android\n\n* 创建一个处理交互的方法类，在方法上面添加@JavascriptInterface，再执行webview.addJavascriptinterface()进行映射。\n* 通过 `WebViewClient`的shouldoverrideUrl()进行链接拦截处理\n* 通过 `WebChromeClient`的onjsaler confirm prompt\n\nandroid 调用 js\n\n* webview.loadurl（“`javascript:`”）\n* `WebView.evaluateJavascript(`)\n\nwebview优化\n\n1.独立进程，android：process 退出system。exit\n\n2.预加载 建立webview维护类。使用mutablecontextwrapper 优先传入applicationcontext，后面可以通过重新设置basecontext更改绑定特定的activity\n\n多渠道包：productflavor配置不同applicationid，将公有库统一维护，各自业务使用风味名+implement进行引用，一些第三方库的一些秘钥使用manifestplaceholder进行维护\n\nintentservice是继承service来创建工作线程，内部原理是在oncreate的时候创建一个handlerthread和他的servicehandler，在onstartcommand里面会点用onstart进行message的发送，在连续进行任务时可以按顺序进行处理。在任务都处理完成之后会自动结束。\n\nhandlerthread： 本身是thread  在run方法中创建当前子线程looper，提供一个getlooper，加了同步锁 对象锁，\n\n1. 单一职责(Single Responsibility Principle)：一个类只做一件事，可读性提高\n2. 里式替换原则( Liskov Substitution Principle):依赖继承和多态，就是能用父类的地方就可以用子类替换，用子类的但不能用父类。\n3. 依赖倒置原则(Dependence Inversion Principle)：依赖抽象，就是模块之间的依赖通过抽象发生。\n4. 开闭原则(Open-Close Principle):不管是实体类,模块还是函数都应该遵循对扩展开放对修改关闭。还是要依赖封装和继承\n5. 接口隔离原则(Interface Segregation Principle):一个类对另一个类的依赖应该建立在最小的接口上，如果接口太大，我们需要把它分割成一些更细小的接口，也是为了降低耦合性\n6. 迪米特原则(Law of Demeter ):也称最少知识原则，也就是说一个类应该对自己需要耦合或者调用的类知道的最少，只需知道该方法即可，实现细节不必知道。\n","slug":"hello-world","published":1,"date":"2022-05-19T07:40:51.120Z","updated":"2022-05-25T07:32:01.022Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3lbac1u0001rgtq21x8g952","content":"<p>第一份工作为青岛日日顺乐家物联科 主要负责多个app维护和功能开发</p>\n<p>app都是通过webview与H5页面混合开发，最后通过多渠道包方式进行不同app的打包</p>\n<p>消息语音播报、H5更新包断点续传下载、短视频录制、直播功能模块等开发</p>\n<p>第二份工作是杭州登虹科技，主要负责部门慧视互联app及其使用的SDK相关维护开发，主要开发语言是java/kotlin/reactnative，还有部分H5页面开发</p>\n<p>多门店巡店 自定义支持单双列切换搭载playerview的list、直播效果编辑模块、自定义开发通用树组件、sdk支持动态域名等功能的开发</p>\n<p>android js 交互</p>\n<p>js调用Android</p>\n<ul>\n<li>创建一个处理交互的方法类，在方法上面添加@JavascriptInterface，再执行webview.addJavascriptinterface()进行映射。</li>\n<li>通过 <code>WebViewClient</code>的shouldoverrideUrl()进行链接拦截处理</li>\n<li>通过 <code>WebChromeClient</code>的onjsaler confirm prompt</li>\n</ul>\n<p>android 调用 js</p>\n<ul>\n<li>webview.loadurl（“<code>javascript:</code>”）</li>\n<li><code>WebView.evaluateJavascript(</code>)</li>\n</ul>\n<p>webview优化</p>\n<p>1.独立进程，android：process 退出system。exit</p>\n<p>2.预加载 建立webview维护类。使用mutablecontextwrapper 优先传入applicationcontext，后面可以通过重新设置basecontext更改绑定特定的activity</p>\n<p>多渠道包：productflavor配置不同applicationid，将公有库统一维护，各自业务使用风味名+implement进行引用，一些第三方库的一些秘钥使用manifestplaceholder进行维护</p>\n<p>intentservice是继承service来创建工作线程，内部原理是在oncreate的时候创建一个handlerthread和他的servicehandler，在onstartcommand里面会点用onstart进行message的发送，在连续进行任务时可以按顺序进行处理。在任务都处理完成之后会自动结束。</p>\n<p>handlerthread： 本身是thread  在run方法中创建当前子线程looper，提供一个getlooper，加了同步锁 对象锁，</p>\n<ol>\n<li>单一职责(Single Responsibility Principle)：一个类只做一件事，可读性提高</li>\n<li>里式替换原则( Liskov Substitution Principle):依赖继承和多态，就是能用父类的地方就可以用子类替换，用子类的但不能用父类。</li>\n<li>依赖倒置原则(Dependence Inversion Principle)：依赖抽象，就是模块之间的依赖通过抽象发生。</li>\n<li>开闭原则(Open-Close Principle):不管是实体类,模块还是函数都应该遵循对扩展开放对修改关闭。还是要依赖封装和继承</li>\n<li>接口隔离原则(Interface Segregation Principle):一个类对另一个类的依赖应该建立在最小的接口上，如果接口太大，我们需要把它分割成一些更细小的接口，也是为了降低耦合性</li>\n<li>迪米特原则(Law of Demeter ):也称最少知识原则，也就是说一个类应该对自己需要耦合或者调用的类知道的最少，只需知道该方法即可，实现细节不必知道。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>第一份工作为青岛日日顺乐家物联科 主要负责多个app维护和功能开发</p>\n<p>app都是通过webview与H5页面混合开发，最后通过多渠道包方式进行不同app的打包</p>\n<p>消息语音播报、H5更新包断点续传下载、短视频录制、直播功能模块等开发</p>\n<p>第二份工作是杭州登虹科技，主要负责部门慧视互联app及其使用的SDK相关维护开发，主要开发语言是java/kotlin/reactnative，还有部分H5页面开发</p>\n<p>多门店巡店 自定义支持单双列切换搭载playerview的list、直播效果编辑模块、自定义开发通用树组件、sdk支持动态域名等功能的开发</p>\n<p>android js 交互</p>\n<p>js调用Android</p>\n<ul>\n<li>创建一个处理交互的方法类，在方法上面添加@JavascriptInterface，再执行webview.addJavascriptinterface()进行映射。</li>\n<li>通过 <code>WebViewClient</code>的shouldoverrideUrl()进行链接拦截处理</li>\n<li>通过 <code>WebChromeClient</code>的onjsaler confirm prompt</li>\n</ul>\n<p>android 调用 js</p>\n<ul>\n<li>webview.loadurl（“<code>javascript:</code>”）</li>\n<li><code>WebView.evaluateJavascript(</code>)</li>\n</ul>\n<p>webview优化</p>\n<p>1.独立进程，android：process 退出system。exit</p>\n<p>2.预加载 建立webview维护类。使用mutablecontextwrapper 优先传入applicationcontext，后面可以通过重新设置basecontext更改绑定特定的activity</p>\n<p>多渠道包：productflavor配置不同applicationid，将公有库统一维护，各自业务使用风味名+implement进行引用，一些第三方库的一些秘钥使用manifestplaceholder进行维护</p>\n<p>intentservice是继承service来创建工作线程，内部原理是在oncreate的时候创建一个handlerthread和他的servicehandler，在onstartcommand里面会点用onstart进行message的发送，在连续进行任务时可以按顺序进行处理。在任务都处理完成之后会自动结束。</p>\n<p>handlerthread： 本身是thread  在run方法中创建当前子线程looper，提供一个getlooper，加了同步锁 对象锁，</p>\n<ol>\n<li>单一职责(Single Responsibility Principle)：一个类只做一件事，可读性提高</li>\n<li>里式替换原则( Liskov Substitution Principle):依赖继承和多态，就是能用父类的地方就可以用子类替换，用子类的但不能用父类。</li>\n<li>依赖倒置原则(Dependence Inversion Principle)：依赖抽象，就是模块之间的依赖通过抽象发生。</li>\n<li>开闭原则(Open-Close Principle):不管是实体类,模块还是函数都应该遵循对扩展开放对修改关闭。还是要依赖封装和继承</li>\n<li>接口隔离原则(Interface Segregation Principle):一个类对另一个类的依赖应该建立在最小的接口上，如果接口太大，我们需要把它分割成一些更细小的接口，也是为了降低耦合性</li>\n<li>迪米特原则(Law of Demeter ):也称最少知识原则，也就是说一个类应该对自己需要耦合或者调用的类知道的最少，只需知道该方法即可，实现细节不必知道。</li>\n</ol>\n"},{"title":"面试题","_content":"# 1.Java面试题\n\n## 1.1Java基础\n\n### ①抽象类与接口区别\n\n* 方法：抽象类可以提供方法的实现，接口中即jdk8以后添加default关键字才可以实现默认实现\n* 参数：抽象类成员变量可以任意创建，接口只能是public static final修饰的变量\n* 构造函数：接口不能拥有构造器，静态代码块、静态方法，抽象类可以\n* 只可继承一个抽象类但是可以实现多个接口\n\n都不可直接实例化是共同点\n\n### ②final、static、synchronized可以修饰什么 什么作用\n\nfinal:\n\n* 类：说明该类功能已经全面了，不允许继承。String类。Interger\n* 方法：该方法不可以被子类重写.final方法编译的时候已经静态绑定了\n* 变量：变量不可变  成员变量或是局部变量修饰可以成为最终变量，配合静态static修饰变量称为常量\n\nstatic：\n\n* 代码块：类进行加载的时候会按顺序执行\n* 方法：静态方法属于类的层面，调用的时候用类名.方法名直接调用\n* 变量：静态变量，存在Java内存模型中的方法区\n* 内部类：可以直接作为一个普通类使用，不需要先实例化一个外部类实例\n\nsynchronized：\n\n* 修饰方法：方法为静态方法为类锁，反之为对象锁\n* 修饰代码块：锁住的是类为类锁，反之为对象锁\n\n### ③String、StringBuffer、StringBUilder\n\nString为字符串常量，如果要进行拼接+操作，会生成一个新的字符串重新赋予变量，连续拼接操作时会造成一些资源损耗还影响效率\n\nStringBuilder是线程不安全的字符串拼接工具类，append\n\nStringBuffer为线程安全的\n\n### ④equals == hashcode\n\n未重写equals等方法时与==一样，对比引用是否一致\n\n一般equals与hashcode需要统一重写，保证equals为true hashcode必须为true  可反性\n\n### ⑤Error和Exception区别\n\nError为程序运行时不可预料的错误情况，发生时会直接杀死进程\n\nException为运行中可预料到的异常情况，分为检查性异常与非检查型异常，检查性异常需要在编写代码时使用try catch捕获\n\n使用throw抛出的是error\n\n### ⑥什么是反射机制\n\njava反射就是在程序运行过程中通过一些类或方法或是变量的信息对其进行获取操作\n\n获取类信息：\n\n```\nobj.getClass()\n类名.class\nClass.forName(\"包名+类名\")\n```\n\n构造方法：\n\n```\nConstuctor[] getConstructors()：获取类中所有被public修饰的构造器\n\nConstructor getConstructor(Class...<?> paramTypes)：根据参数类型获取类中某个构造器，该构造器必须被public修饰\n\nConstructor[] getDeclaredConstructors()：获取类中所有构造器\n\nConstructor getDeclaredConstructor(class...<?> paramTypes)：根据参数类型获取对应的构造器\n\nClass clazz = Class.forName(\"com.bean.SmallPineapple\");\n\nConstructor constructor = clazz.getConstructor(String.class, int.class);\n\nconstructor.setAccessible(true);\n\nSmallPineapple smallPineapple2 = (SmallPineapple) constructor.newInstance(\"小菠萝\", 21);\n\nsmallPineapple2.getInfo();\n```\n\n变量：\n\n```\nField[] getFields()：获取类中所有被public、protected修饰的所有变量\n\nField getField(String name)：根据变量名获取类中的一个变量，获取是被public和protected修饰的\n\nField[] getDeclaredFields()：获取类中所有的变量，但无法获取继承下来的变量\n\nField getDeclaredField(String name)：根据姓名获取类中的某个变量，无法获取继承下来的变量\n```\n\n方法：\n\n```\nMethod[] getMethods()：获取类中被public、protected修饰的所有方法\n\nMethod getMethod(String name, Class...<?> paramTypes)：根据名字和参数类型获取对应方法，该方法必须被public、protected修饰\n\nMethod[] getDeclaredMethods()：获取所有方法，但无法获取继承下来的方法\n\nMethod getDeclaredMethod(String name, Class...<?> paramTypes)：根据名字和参数类型获取对应方法，无法获取继承下来的方法\n```\n\n注解：只有@Retension为RUNTIME时才能通过反射获取该注解\n\n```\nAnnotation[] getAnnotations()：获取该对象上的所有注解\n\nAnnotation getAnnotation(Class annotaionClass)：传入注解类型，获取该对象上的特定一个注解\n\nAnnotation[] getDeclaredAnnotations()：获取该对象上的显式标注的所有注解，无法获取继承下来的注解\n\nAnnotation getDeclaredAnnotation(Class annotationClass)：根据注解类型，获取该对象上的特定一个注解，无法获取继承下来的注解\n```\n\n### ⑦IO流分几种\n\nIO流分为字节流和字符流，与之对应的抽象类有inputstream、outputstream、reader、writer\n\n字节流可以传递存储任何类型的数据，字符流只能处理字符、字符串，使用指定的字符集进行编码操作\n\nBIO：同步阻塞式IO  NIO：同步非阻塞 AIO：NIO升级也叫NIO2，异步非阻塞\n\n### ⑧泛型类型擦除\n\n类型擦除发生在编译过程中，所有泛型信息都会被擦除\n\n### ⑨注解的理解\n\n本质：做一个标识，通过这个标识对代码规范、变量值做一些修饰。主要划分为三类\n\n\n| Source  | 仅仅存在在.java文件，编译成.class文件就消失了。作用为：让开发者按照注解的规范编写代码。例如：[@OverRide](https://github.com/OverRide)                        |                                                        |\n| --------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------- |\n| Class   | 在前期编译期的流程中，会被处理成.class内容，与原生代码效率几乎相同。<br />作用为：自动生成.class文件，做一些辅助性工作。例如：ButterKnife、GreenDao、ARouter | 效率和原生代码相当                                     |\n| Runtime | 编译成.class文件之后，依旧以注解的方式存在。而是在运行期生效。<br />作用为：在运行期，通过反射做一些辅助性工作。例如：xUtils                                 | 由于集中使用遍历+反射，因此效率较低。而且在9.0禁用反射 |\n\n## 1.2 Java集合\n\n### ①list、set、map\n\nIterator是所有集合的总接口，Collection继承于Iterator。list有序可重复，set无序不可重复，map键值对，键唯一。\n\nlist、set继承自collection。ArrayList数组结构，存储地址连续、linkedList双向链表结构。\n\nhashset哈希表实现，无序可放入null\n\ntreeset是二叉树红黑树结构实现的，自动排序不允许null值\n\nhashmap hashtable concurrentHashMap、linkedhashmap\n\n## 1.3 Java多线程\n\n### ① java 多线程的方式\n\n```\n1. 继承Thread，重写run方法，用start启动\n2. 自定义runnable，放入thread启动\n3.通过线程池、callable、future实现有返回结果的多线程\n```\n\n### ② 线程的状态\n\n* new 创建状态\n* runnable 运行\n* blocked 阻塞\n* waiting 等待\n* timed_waiting 超时等待\n* end 终止\n\n### ③ 实现多线程中的同步\n\n* volatile 简单逻辑可以实现 简单的 set get\n* synchronized\n* reentrantlock\n\n  ```\n  1. Lock lock = new ReentrantLock();\n     try {\n              todo.........\n          } finally {\n              lock.unlock();\n          }\n  也可以尝试获取锁\n  if (lock.tryLock(1, TimeUnit.SECONDS)) {\n      try {\n          ...\n      } finally {\n          lock.unlock();\n      }\n  }\n  2.配合condition的await和signal模仿obj的wait、notify\n  3.  ReadWriteLock rwlock = new ReentrantReadWriteLock();\n      Lock rlock = rwlock.readLock();\n      Lock wlock = rwlock.writeLock();\n  ```\n* cas   unsafe类\n* Object.wait/notify\n\n  ```\n  wait属于object类中的方法，调用后释放锁，将当前线程a放入该对象锁的等待池，线程b执行notify会通知等待池，使线程a从等待池进入阻塞队列等到线程b释放锁后线程a竞争锁继续执行。\n  notifyall会把等待池里所有的线程唤醒去竞争\n  ```\n\n### ④ 线程池\n\n* 常见线程池\n\n  ```\n  Executors.newFixedThreadPool 使用的是linkedblockingqueue  指定核心线程数\n  Executors.newCachedThreadPool 使用的是SynchronousQueue\n  Executors.newSingleThreadExecutor 使用的是LinkedBlokingQueue\n  Executors.newScheduledThreadPool\n\n  ThreadPoolExecutor  核心线程数 最大线程数 超时回收时间 时间单位 任务处理队列 线程工厂\n  ```\n\n  核心线程-》阻塞队列-》非核心线程-》handler拒绝任务提交\n* 常见的任务处理阻塞队列\n  ArrayBlockingQueue 有界数组阻塞队列\n  LinkedBlockingQueue 无界链表阻塞队列\n  SynchronousQueue 无存储队列\n  PriorityBlockingQueue 优先级阻塞队列\n* shutdown 关闭线程池——等添加到线程池中的任务全部完成才退出\n  shutdownNow  关闭线程池并中断任务  调用Tread.interrupt中断任务 但线程无sleep、wait、condition、定时锁等是无法中断新城，有可能需要等所有线程执行完毕关闭\n\n### ⑤ synchronized与volatile\n\nvolatile：\n\n1. 保证变量在不同线程进行操作的可见性\n2. 禁止指令重排\n   指令重排是指指令乱序执行，有时在条件允许情况下，为了避开获取一条指令所需的数据而造成的等待，会通过乱序执行提高效率。添加一个内存屏障，指令乱序时不能把后面的指令排序移到内存屏障之前\n\nsynchronize：\n\n偏向锁、轻量级锁。自旋锁、重量级锁\n\n### ⑥ 死锁\n\n当线程a持有独占锁1，并尝试去获取独占锁2的同时，线程b持有独占锁2，并尝试获取独占锁1，这时两个线程都出去获取对方的独占锁处于阻塞状态，产生了死锁。\n\n1. 互斥条件：一个资源只能被一个线程使用 独占锁\n2. 请求与保持条件：一个线程因请求资源被阻塞，对已获得的资源保持不释放\n3. 不剥夺条件： 线程获得资源在未使用完之前，不能强行剥夺\n4. 循环等待：若干线程之间形成头尾相接的循环资源等待关系\n\n解决办法：\n\n1. 加锁顺序控制 按照一定顺序加锁\n2. 加锁时限 线索尝试获取锁时加上时限，超时则放弃对锁的请求，并释放自己占有的锁\n3. 死锁检测 加锁时将线程与锁存在类似map中，每当有线程请求锁失败时可以判断是否有循环锁占有和请求的关系进行处理\n\n### ⑦ 线程、进程\n\n一个程序至少有一个进程，一个进程至少有一个线程\n\n1. 进程是资源分配最小单位，线城市程序执行的最小单位。\n2. 进程有自己独立的地址空间，每启动一个进程系统会为其分配地址空间。线程没有独立的地址空间，统一进程的线程共享进程的地址空间\n3. 进程之间资源独立，同一进程内线程共享本晋城资源\n4. 每个独立进程有一个运行入口，顺序执行队列和程序出口。线程不能独立执行，依存于程序进程中\n\n### ⑧ ThreadLocal\n\n1. 原理：\n   每一个tread内部维护了一个threadlocalmap，内部维护了一个数组，数组里面存储的数据是一个entry内部类，key为threadlocal的弱引用，value为我们要存储的数据的强引用。\n   set方法：从当前线程获取他的localthreadmap，根据hashcode与数组长度计算在数组中存储的位置，分为几个情况\n   如果以前在当前位置存储过，更新后返回，发生hash冲突依次向后寻找。返回\n   如果当前key为null，也就是被回收了，会先向前遍历直到entry为空，找到第一个该回收的位置，然后再向后遍历查找是否和当前key匹配的有的话进行位置交换及清理,返回\n   如果没有存储过就直接新建存储，进行清理并检查需不需要扩容；\n   在执行get操作时，从当前线程获取他的localthreadmap，根据threadlocal的hashcode与数组长度计算存储的数组位置，通过当前的threadlocal获取我们存储的值。\n2. 内存泄漏：因为value为强引用，threadlocal回收后未去回收他的value就会发生内存泄漏，不用时应该保证执行remove或保证与线程生命周期相同\n\n## 1.4 Java内存\n\n### ① 类的加载\n\n* android中有5个类加载器：ClassLoader（所有类加载器的抽象基类）、BootClassLoader（用于加在android系统的类，classloader的内部类，开发者无法调用）、BaseDexClassLoader（继承ClassLoader）、PathClassLoader（继承于BaseDexClassLoader，通常用于加载我们自己写的类含第三方库，但不局限于此）、DexClassLoader（继承于BaseDexClassLoader，通常用于执行动态加载，能够加在指定路径的apk、jar、zip、dex文件，因此很多热修复和插件化方案使用）\n* 加载时使用双亲委派模式加载，先以递归方式向上级父加载器验证是否已经加载，若没被加载过在从最顶级加载器进行加载操作，加载失败逐级向下进行加载。保证类只会被加载一次。\n* 加载（通过类的全限定名获取类的二进制字节流，将静态存储结构转化为方法区的运行数据结构，在内存中生成Class对象，作为这个类的各种数据的方位入口）-》\n  连接（1.验证——语法是否通过；2.准备——变量分配内存；3.解析——接口、字段和方法的符号引用转为直接引用）-》\n  初始化（对变量和一些代码块进行初始化及执行）\n\n### ② 引用类型\n\n1. 强引用：垃圾回收器不会回收，及时内存空间不足，jvm宁愿outofmemoryerror程序异常终止也不随意回收强引用对象\n2. 软引用：如果一个对象只有软引用，内存够用的时候不会对其进行回收，当内存不足时hiuduiqijinxinghuishou，可以和引用队列联合使用\n3. 弱引用：如果一个对象只有弱引用，垃圾回收器检测到就会对其进行回收。由于垃圾回收器所在线程优先级很低不一定会快发现，可以和引用队列联合使用\n4. 虚引用：任何时候都可能被回收，主要用于跟踪对象呗垃圾回收器回收的活动。必须与ReferenceQueue联合使用\n\n### ③ Java内存模型\n\n1. 堆  对象\n2. 栈  线程栈帧 线程私有\n3. 本地方发栈\n4. 方法区 加载的类信息、常量、静态变量、即时编译器编译后的代码\n5. 程序计数器\n\n### ④ Java内存回收机制\n\n* 回收检测有两种：\n  引用计数法：有对这个对象的引用+1，不再引用-1\n  可达性分析：以GCRoots对象为起点，从这个节点从上到下搜索，路径称为引用链，当一个对象没有任何引用链与GCRoots连接时，就说明当前对象不可达可以回收\n  GC Roots对象通常包括：\n\n  ```\n  虚拟机栈中引用的对象——栈帧中的本地变量表\n  方法中类的静态属性引用的对象\n  方法区常量引用的对象\n  Native方法引用的对象\n  ```\n* 回收算法：\n\n  ```\n  1. 标记清除：\n     扫描并标记存活目标，标记完成后再扫描未标记的对象对其进行回收。存活对象多时效率高\n  但是会造成内存碎片。\n  2. 标记整理：\n     在标记清除基础上，将存活的内存进行移动整理更新指针。适合对象存活率高的场景——老\n  年代回收。\n  3. 复制：\n     将内存分为大小相等两块，每次只是用一块。当内存使用完后，将存活对象复制到另一侧，\n  再将该区域全部清除。适用于对象存活率低情况——新生代。\n  4. 分代收集：\n     不同的对象生命周期不同，不同的生命周期的对象放置在堆中的不同区域，以不同的策略\n  进行回收提高效率。新生代使用复制算法；老年代使用标记清除或标记整理。分代收集一般分\n  为新生代，老年代和永久代。\n     新生代：所有新对象首先都放在新生代，按照8：1：1比例分为一个Eden区和两个survivor区。\n  大部分对象在Eden区生成，回收时先将Eden存活对象复制到survivor0然后清空Eden，\n  当这survivor0存放满，将Eden区域survivor0中存活的对象复制到survivor1中，\n  清空Eden与survivor0，然后将survivor0与survivor1互换保证survivor1为空。\n  当survivor1不足存放时就会将存活对象存放至老年代。若是老年代满了就会出发full GC，\n  也就是新老年代都进行回收。新生代的GC叫做MinorGC发生频率高。\n     老年代： 内存大概是新生代的两倍，老年代中的对象存活时间长。\n     永久代： 主要存放静态文件，如java类、方法等。对垃圾回收没有显著影响，用来解决\n  动态代理或是反射等等运行中新增的类的内存。\n\n  ```\n\n### ⑤ jvm、dalvik和art\n\n* jvm：java虚拟机，并不是某个特定虚拟机的实现，而是任何能运行java字节码的虚拟机实现\n* dalvik：是google创建的用于android的虚拟机，但其严格来说不算jvm，5.0被art替代\n  基于寄存器，jvm基于堆栈；有自己的字节码不是java字节码；jit即时编译\n* art：android run time。4.4-6.0采用安装时全部编译为机器码的方式实现，7.0开始默认不全部编译，采用解释执行+jit+空闲时间aot以改善安装耗时。\n  aot预编译在安装过程中，将所有字节码变异成机器码，运行时直接调用。\n\n# 2 Kotlin\n\n## 2.1 kotlin语言特性\n\n### ① 介绍kotlin其特性\n\n* 能与java互相调用\n* 减少样板代码\n* 可将kotlin编译为无需虚拟机就可以运行的原生二进制文件\n* 支持高阶函数\n* 支持协程\n* 语言层面解决空指针问题\n* 对lambda表达式更好地支持\n\n### ② @JvmOverloads作用\n\n在有默认参数值的方法中使用@JvmOverloads注解会重载多个方法。\n\n### ③ kotlin中单例与java对比\n\n1. 线程不安全饿汉式\n\n   ```\n   kotlin：\n   object Single{\n   }\n\n   java：\n\n   ```\n2. ```\n\n   ```\n\n```\n\n```\n","source":"_posts/interview.md","raw":"---\ntitle: 面试题\ncategories:\n- Start\n---\n# 1.Java面试题\n\n## 1.1Java基础\n\n### ①抽象类与接口区别\n\n* 方法：抽象类可以提供方法的实现，接口中即jdk8以后添加default关键字才可以实现默认实现\n* 参数：抽象类成员变量可以任意创建，接口只能是public static final修饰的变量\n* 构造函数：接口不能拥有构造器，静态代码块、静态方法，抽象类可以\n* 只可继承一个抽象类但是可以实现多个接口\n\n都不可直接实例化是共同点\n\n### ②final、static、synchronized可以修饰什么 什么作用\n\nfinal:\n\n* 类：说明该类功能已经全面了，不允许继承。String类。Interger\n* 方法：该方法不可以被子类重写.final方法编译的时候已经静态绑定了\n* 变量：变量不可变  成员变量或是局部变量修饰可以成为最终变量，配合静态static修饰变量称为常量\n\nstatic：\n\n* 代码块：类进行加载的时候会按顺序执行\n* 方法：静态方法属于类的层面，调用的时候用类名.方法名直接调用\n* 变量：静态变量，存在Java内存模型中的方法区\n* 内部类：可以直接作为一个普通类使用，不需要先实例化一个外部类实例\n\nsynchronized：\n\n* 修饰方法：方法为静态方法为类锁，反之为对象锁\n* 修饰代码块：锁住的是类为类锁，反之为对象锁\n\n### ③String、StringBuffer、StringBUilder\n\nString为字符串常量，如果要进行拼接+操作，会生成一个新的字符串重新赋予变量，连续拼接操作时会造成一些资源损耗还影响效率\n\nStringBuilder是线程不安全的字符串拼接工具类，append\n\nStringBuffer为线程安全的\n\n### ④equals == hashcode\n\n未重写equals等方法时与==一样，对比引用是否一致\n\n一般equals与hashcode需要统一重写，保证equals为true hashcode必须为true  可反性\n\n### ⑤Error和Exception区别\n\nError为程序运行时不可预料的错误情况，发生时会直接杀死进程\n\nException为运行中可预料到的异常情况，分为检查性异常与非检查型异常，检查性异常需要在编写代码时使用try catch捕获\n\n使用throw抛出的是error\n\n### ⑥什么是反射机制\n\njava反射就是在程序运行过程中通过一些类或方法或是变量的信息对其进行获取操作\n\n获取类信息：\n\n```\nobj.getClass()\n类名.class\nClass.forName(\"包名+类名\")\n```\n\n构造方法：\n\n```\nConstuctor[] getConstructors()：获取类中所有被public修饰的构造器\n\nConstructor getConstructor(Class...<?> paramTypes)：根据参数类型获取类中某个构造器，该构造器必须被public修饰\n\nConstructor[] getDeclaredConstructors()：获取类中所有构造器\n\nConstructor getDeclaredConstructor(class...<?> paramTypes)：根据参数类型获取对应的构造器\n\nClass clazz = Class.forName(\"com.bean.SmallPineapple\");\n\nConstructor constructor = clazz.getConstructor(String.class, int.class);\n\nconstructor.setAccessible(true);\n\nSmallPineapple smallPineapple2 = (SmallPineapple) constructor.newInstance(\"小菠萝\", 21);\n\nsmallPineapple2.getInfo();\n```\n\n变量：\n\n```\nField[] getFields()：获取类中所有被public、protected修饰的所有变量\n\nField getField(String name)：根据变量名获取类中的一个变量，获取是被public和protected修饰的\n\nField[] getDeclaredFields()：获取类中所有的变量，但无法获取继承下来的变量\n\nField getDeclaredField(String name)：根据姓名获取类中的某个变量，无法获取继承下来的变量\n```\n\n方法：\n\n```\nMethod[] getMethods()：获取类中被public、protected修饰的所有方法\n\nMethod getMethod(String name, Class...<?> paramTypes)：根据名字和参数类型获取对应方法，该方法必须被public、protected修饰\n\nMethod[] getDeclaredMethods()：获取所有方法，但无法获取继承下来的方法\n\nMethod getDeclaredMethod(String name, Class...<?> paramTypes)：根据名字和参数类型获取对应方法，无法获取继承下来的方法\n```\n\n注解：只有@Retension为RUNTIME时才能通过反射获取该注解\n\n```\nAnnotation[] getAnnotations()：获取该对象上的所有注解\n\nAnnotation getAnnotation(Class annotaionClass)：传入注解类型，获取该对象上的特定一个注解\n\nAnnotation[] getDeclaredAnnotations()：获取该对象上的显式标注的所有注解，无法获取继承下来的注解\n\nAnnotation getDeclaredAnnotation(Class annotationClass)：根据注解类型，获取该对象上的特定一个注解，无法获取继承下来的注解\n```\n\n### ⑦IO流分几种\n\nIO流分为字节流和字符流，与之对应的抽象类有inputstream、outputstream、reader、writer\n\n字节流可以传递存储任何类型的数据，字符流只能处理字符、字符串，使用指定的字符集进行编码操作\n\nBIO：同步阻塞式IO  NIO：同步非阻塞 AIO：NIO升级也叫NIO2，异步非阻塞\n\n### ⑧泛型类型擦除\n\n类型擦除发生在编译过程中，所有泛型信息都会被擦除\n\n### ⑨注解的理解\n\n本质：做一个标识，通过这个标识对代码规范、变量值做一些修饰。主要划分为三类\n\n\n| Source  | 仅仅存在在.java文件，编译成.class文件就消失了。作用为：让开发者按照注解的规范编写代码。例如：[@OverRide](https://github.com/OverRide)                        |                                                        |\n| --------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------- |\n| Class   | 在前期编译期的流程中，会被处理成.class内容，与原生代码效率几乎相同。<br />作用为：自动生成.class文件，做一些辅助性工作。例如：ButterKnife、GreenDao、ARouter | 效率和原生代码相当                                     |\n| Runtime | 编译成.class文件之后，依旧以注解的方式存在。而是在运行期生效。<br />作用为：在运行期，通过反射做一些辅助性工作。例如：xUtils                                 | 由于集中使用遍历+反射，因此效率较低。而且在9.0禁用反射 |\n\n## 1.2 Java集合\n\n### ①list、set、map\n\nIterator是所有集合的总接口，Collection继承于Iterator。list有序可重复，set无序不可重复，map键值对，键唯一。\n\nlist、set继承自collection。ArrayList数组结构，存储地址连续、linkedList双向链表结构。\n\nhashset哈希表实现，无序可放入null\n\ntreeset是二叉树红黑树结构实现的，自动排序不允许null值\n\nhashmap hashtable concurrentHashMap、linkedhashmap\n\n## 1.3 Java多线程\n\n### ① java 多线程的方式\n\n```\n1. 继承Thread，重写run方法，用start启动\n2. 自定义runnable，放入thread启动\n3.通过线程池、callable、future实现有返回结果的多线程\n```\n\n### ② 线程的状态\n\n* new 创建状态\n* runnable 运行\n* blocked 阻塞\n* waiting 等待\n* timed_waiting 超时等待\n* end 终止\n\n### ③ 实现多线程中的同步\n\n* volatile 简单逻辑可以实现 简单的 set get\n* synchronized\n* reentrantlock\n\n  ```\n  1. Lock lock = new ReentrantLock();\n     try {\n              todo.........\n          } finally {\n              lock.unlock();\n          }\n  也可以尝试获取锁\n  if (lock.tryLock(1, TimeUnit.SECONDS)) {\n      try {\n          ...\n      } finally {\n          lock.unlock();\n      }\n  }\n  2.配合condition的await和signal模仿obj的wait、notify\n  3.  ReadWriteLock rwlock = new ReentrantReadWriteLock();\n      Lock rlock = rwlock.readLock();\n      Lock wlock = rwlock.writeLock();\n  ```\n* cas   unsafe类\n* Object.wait/notify\n\n  ```\n  wait属于object类中的方法，调用后释放锁，将当前线程a放入该对象锁的等待池，线程b执行notify会通知等待池，使线程a从等待池进入阻塞队列等到线程b释放锁后线程a竞争锁继续执行。\n  notifyall会把等待池里所有的线程唤醒去竞争\n  ```\n\n### ④ 线程池\n\n* 常见线程池\n\n  ```\n  Executors.newFixedThreadPool 使用的是linkedblockingqueue  指定核心线程数\n  Executors.newCachedThreadPool 使用的是SynchronousQueue\n  Executors.newSingleThreadExecutor 使用的是LinkedBlokingQueue\n  Executors.newScheduledThreadPool\n\n  ThreadPoolExecutor  核心线程数 最大线程数 超时回收时间 时间单位 任务处理队列 线程工厂\n  ```\n\n  核心线程-》阻塞队列-》非核心线程-》handler拒绝任务提交\n* 常见的任务处理阻塞队列\n  ArrayBlockingQueue 有界数组阻塞队列\n  LinkedBlockingQueue 无界链表阻塞队列\n  SynchronousQueue 无存储队列\n  PriorityBlockingQueue 优先级阻塞队列\n* shutdown 关闭线程池——等添加到线程池中的任务全部完成才退出\n  shutdownNow  关闭线程池并中断任务  调用Tread.interrupt中断任务 但线程无sleep、wait、condition、定时锁等是无法中断新城，有可能需要等所有线程执行完毕关闭\n\n### ⑤ synchronized与volatile\n\nvolatile：\n\n1. 保证变量在不同线程进行操作的可见性\n2. 禁止指令重排\n   指令重排是指指令乱序执行，有时在条件允许情况下，为了避开获取一条指令所需的数据而造成的等待，会通过乱序执行提高效率。添加一个内存屏障，指令乱序时不能把后面的指令排序移到内存屏障之前\n\nsynchronize：\n\n偏向锁、轻量级锁。自旋锁、重量级锁\n\n### ⑥ 死锁\n\n当线程a持有独占锁1，并尝试去获取独占锁2的同时，线程b持有独占锁2，并尝试获取独占锁1，这时两个线程都出去获取对方的独占锁处于阻塞状态，产生了死锁。\n\n1. 互斥条件：一个资源只能被一个线程使用 独占锁\n2. 请求与保持条件：一个线程因请求资源被阻塞，对已获得的资源保持不释放\n3. 不剥夺条件： 线程获得资源在未使用完之前，不能强行剥夺\n4. 循环等待：若干线程之间形成头尾相接的循环资源等待关系\n\n解决办法：\n\n1. 加锁顺序控制 按照一定顺序加锁\n2. 加锁时限 线索尝试获取锁时加上时限，超时则放弃对锁的请求，并释放自己占有的锁\n3. 死锁检测 加锁时将线程与锁存在类似map中，每当有线程请求锁失败时可以判断是否有循环锁占有和请求的关系进行处理\n\n### ⑦ 线程、进程\n\n一个程序至少有一个进程，一个进程至少有一个线程\n\n1. 进程是资源分配最小单位，线城市程序执行的最小单位。\n2. 进程有自己独立的地址空间，每启动一个进程系统会为其分配地址空间。线程没有独立的地址空间，统一进程的线程共享进程的地址空间\n3. 进程之间资源独立，同一进程内线程共享本晋城资源\n4. 每个独立进程有一个运行入口，顺序执行队列和程序出口。线程不能独立执行，依存于程序进程中\n\n### ⑧ ThreadLocal\n\n1. 原理：\n   每一个tread内部维护了一个threadlocalmap，内部维护了一个数组，数组里面存储的数据是一个entry内部类，key为threadlocal的弱引用，value为我们要存储的数据的强引用。\n   set方法：从当前线程获取他的localthreadmap，根据hashcode与数组长度计算在数组中存储的位置，分为几个情况\n   如果以前在当前位置存储过，更新后返回，发生hash冲突依次向后寻找。返回\n   如果当前key为null，也就是被回收了，会先向前遍历直到entry为空，找到第一个该回收的位置，然后再向后遍历查找是否和当前key匹配的有的话进行位置交换及清理,返回\n   如果没有存储过就直接新建存储，进行清理并检查需不需要扩容；\n   在执行get操作时，从当前线程获取他的localthreadmap，根据threadlocal的hashcode与数组长度计算存储的数组位置，通过当前的threadlocal获取我们存储的值。\n2. 内存泄漏：因为value为强引用，threadlocal回收后未去回收他的value就会发生内存泄漏，不用时应该保证执行remove或保证与线程生命周期相同\n\n## 1.4 Java内存\n\n### ① 类的加载\n\n* android中有5个类加载器：ClassLoader（所有类加载器的抽象基类）、BootClassLoader（用于加在android系统的类，classloader的内部类，开发者无法调用）、BaseDexClassLoader（继承ClassLoader）、PathClassLoader（继承于BaseDexClassLoader，通常用于加载我们自己写的类含第三方库，但不局限于此）、DexClassLoader（继承于BaseDexClassLoader，通常用于执行动态加载，能够加在指定路径的apk、jar、zip、dex文件，因此很多热修复和插件化方案使用）\n* 加载时使用双亲委派模式加载，先以递归方式向上级父加载器验证是否已经加载，若没被加载过在从最顶级加载器进行加载操作，加载失败逐级向下进行加载。保证类只会被加载一次。\n* 加载（通过类的全限定名获取类的二进制字节流，将静态存储结构转化为方法区的运行数据结构，在内存中生成Class对象，作为这个类的各种数据的方位入口）-》\n  连接（1.验证——语法是否通过；2.准备——变量分配内存；3.解析——接口、字段和方法的符号引用转为直接引用）-》\n  初始化（对变量和一些代码块进行初始化及执行）\n\n### ② 引用类型\n\n1. 强引用：垃圾回收器不会回收，及时内存空间不足，jvm宁愿outofmemoryerror程序异常终止也不随意回收强引用对象\n2. 软引用：如果一个对象只有软引用，内存够用的时候不会对其进行回收，当内存不足时hiuduiqijinxinghuishou，可以和引用队列联合使用\n3. 弱引用：如果一个对象只有弱引用，垃圾回收器检测到就会对其进行回收。由于垃圾回收器所在线程优先级很低不一定会快发现，可以和引用队列联合使用\n4. 虚引用：任何时候都可能被回收，主要用于跟踪对象呗垃圾回收器回收的活动。必须与ReferenceQueue联合使用\n\n### ③ Java内存模型\n\n1. 堆  对象\n2. 栈  线程栈帧 线程私有\n3. 本地方发栈\n4. 方法区 加载的类信息、常量、静态变量、即时编译器编译后的代码\n5. 程序计数器\n\n### ④ Java内存回收机制\n\n* 回收检测有两种：\n  引用计数法：有对这个对象的引用+1，不再引用-1\n  可达性分析：以GCRoots对象为起点，从这个节点从上到下搜索，路径称为引用链，当一个对象没有任何引用链与GCRoots连接时，就说明当前对象不可达可以回收\n  GC Roots对象通常包括：\n\n  ```\n  虚拟机栈中引用的对象——栈帧中的本地变量表\n  方法中类的静态属性引用的对象\n  方法区常量引用的对象\n  Native方法引用的对象\n  ```\n* 回收算法：\n\n  ```\n  1. 标记清除：\n     扫描并标记存活目标，标记完成后再扫描未标记的对象对其进行回收。存活对象多时效率高\n  但是会造成内存碎片。\n  2. 标记整理：\n     在标记清除基础上，将存活的内存进行移动整理更新指针。适合对象存活率高的场景——老\n  年代回收。\n  3. 复制：\n     将内存分为大小相等两块，每次只是用一块。当内存使用完后，将存活对象复制到另一侧，\n  再将该区域全部清除。适用于对象存活率低情况——新生代。\n  4. 分代收集：\n     不同的对象生命周期不同，不同的生命周期的对象放置在堆中的不同区域，以不同的策略\n  进行回收提高效率。新生代使用复制算法；老年代使用标记清除或标记整理。分代收集一般分\n  为新生代，老年代和永久代。\n     新生代：所有新对象首先都放在新生代，按照8：1：1比例分为一个Eden区和两个survivor区。\n  大部分对象在Eden区生成，回收时先将Eden存活对象复制到survivor0然后清空Eden，\n  当这survivor0存放满，将Eden区域survivor0中存活的对象复制到survivor1中，\n  清空Eden与survivor0，然后将survivor0与survivor1互换保证survivor1为空。\n  当survivor1不足存放时就会将存活对象存放至老年代。若是老年代满了就会出发full GC，\n  也就是新老年代都进行回收。新生代的GC叫做MinorGC发生频率高。\n     老年代： 内存大概是新生代的两倍，老年代中的对象存活时间长。\n     永久代： 主要存放静态文件，如java类、方法等。对垃圾回收没有显著影响，用来解决\n  动态代理或是反射等等运行中新增的类的内存。\n\n  ```\n\n### ⑤ jvm、dalvik和art\n\n* jvm：java虚拟机，并不是某个特定虚拟机的实现，而是任何能运行java字节码的虚拟机实现\n* dalvik：是google创建的用于android的虚拟机，但其严格来说不算jvm，5.0被art替代\n  基于寄存器，jvm基于堆栈；有自己的字节码不是java字节码；jit即时编译\n* art：android run time。4.4-6.0采用安装时全部编译为机器码的方式实现，7.0开始默认不全部编译，采用解释执行+jit+空闲时间aot以改善安装耗时。\n  aot预编译在安装过程中，将所有字节码变异成机器码，运行时直接调用。\n\n# 2 Kotlin\n\n## 2.1 kotlin语言特性\n\n### ① 介绍kotlin其特性\n\n* 能与java互相调用\n* 减少样板代码\n* 可将kotlin编译为无需虚拟机就可以运行的原生二进制文件\n* 支持高阶函数\n* 支持协程\n* 语言层面解决空指针问题\n* 对lambda表达式更好地支持\n\n### ② @JvmOverloads作用\n\n在有默认参数值的方法中使用@JvmOverloads注解会重载多个方法。\n\n### ③ kotlin中单例与java对比\n\n1. 线程不安全饿汉式\n\n   ```\n   kotlin：\n   object Single{\n   }\n\n   java：\n\n   ```\n2. ```\n\n   ```\n\n```\n\n```\n","slug":"interview","published":1,"date":"2022-05-24T07:22:25.288Z","updated":"2022-05-29T03:17:51.081Z","_id":"cl3lbac250006rgtq4a5jdny4","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"1-Java面试题\"><a href=\"#1-Java面试题\" class=\"headerlink\" title=\"1.Java面试题\"></a>1.Java面试题</h1><h2 id=\"1-1Java基础\"><a href=\"#1-1Java基础\" class=\"headerlink\" title=\"1.1Java基础\"></a>1.1Java基础</h2><h3 id=\"①抽象类与接口区别\"><a href=\"#①抽象类与接口区别\" class=\"headerlink\" title=\"①抽象类与接口区别\"></a>①抽象类与接口区别</h3><ul>\n<li>方法：抽象类可以提供方法的实现，接口中即jdk8以后添加default关键字才可以实现默认实现</li>\n<li>参数：抽象类成员变量可以任意创建，接口只能是public static final修饰的变量</li>\n<li>构造函数：接口不能拥有构造器，静态代码块、静态方法，抽象类可以</li>\n<li>只可继承一个抽象类但是可以实现多个接口</li>\n</ul>\n<p>都不可直接实例化是共同点</p>\n<h3 id=\"②final、static、synchronized可以修饰什么-什么作用\"><a href=\"#②final、static、synchronized可以修饰什么-什么作用\" class=\"headerlink\" title=\"②final、static、synchronized可以修饰什么 什么作用\"></a>②final、static、synchronized可以修饰什么 什么作用</h3><p>final:</p>\n<ul>\n<li>类：说明该类功能已经全面了，不允许继承。String类。Interger</li>\n<li>方法：该方法不可以被子类重写.final方法编译的时候已经静态绑定了</li>\n<li>变量：变量不可变  成员变量或是局部变量修饰可以成为最终变量，配合静态static修饰变量称为常量</li>\n</ul>\n<p>static：</p>\n<ul>\n<li>代码块：类进行加载的时候会按顺序执行</li>\n<li>方法：静态方法属于类的层面，调用的时候用类名.方法名直接调用</li>\n<li>变量：静态变量，存在Java内存模型中的方法区</li>\n<li>内部类：可以直接作为一个普通类使用，不需要先实例化一个外部类实例</li>\n</ul>\n<p>synchronized：</p>\n<ul>\n<li>修饰方法：方法为静态方法为类锁，反之为对象锁</li>\n<li>修饰代码块：锁住的是类为类锁，反之为对象锁</li>\n</ul>\n<h3 id=\"③String、StringBuffer、StringBUilder\"><a href=\"#③String、StringBuffer、StringBUilder\" class=\"headerlink\" title=\"③String、StringBuffer、StringBUilder\"></a>③String、StringBuffer、StringBUilder</h3><p>String为字符串常量，如果要进行拼接+操作，会生成一个新的字符串重新赋予变量，连续拼接操作时会造成一些资源损耗还影响效率</p>\n<p>StringBuilder是线程不安全的字符串拼接工具类，append</p>\n<p>StringBuffer为线程安全的</p>\n<h3 id=\"④equals-hashcode\"><a href=\"#④equals-hashcode\" class=\"headerlink\" title=\"④equals == hashcode\"></a>④equals == hashcode</h3><p>未重写equals等方法时与==一样，对比引用是否一致</p>\n<p>一般equals与hashcode需要统一重写，保证equals为true hashcode必须为true  可反性</p>\n<h3 id=\"⑤Error和Exception区别\"><a href=\"#⑤Error和Exception区别\" class=\"headerlink\" title=\"⑤Error和Exception区别\"></a>⑤Error和Exception区别</h3><p>Error为程序运行时不可预料的错误情况，发生时会直接杀死进程</p>\n<p>Exception为运行中可预料到的异常情况，分为检查性异常与非检查型异常，检查性异常需要在编写代码时使用try catch捕获</p>\n<p>使用throw抛出的是error</p>\n<h3 id=\"⑥什么是反射机制\"><a href=\"#⑥什么是反射机制\" class=\"headerlink\" title=\"⑥什么是反射机制\"></a>⑥什么是反射机制</h3><p>java反射就是在程序运行过程中通过一些类或方法或是变量的信息对其进行获取操作</p>\n<p>获取类信息：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">obj.getClass()</span><br><span class=\"line\">类名.class</span><br><span class=\"line\">Class.forName(&quot;包名+类名&quot;)</span><br></pre></td></tr></table></figure>\n\n<p>构造方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Constuctor[] getConstructors()：获取类中所有被public修饰的构造器</span><br><span class=\"line\"></span><br><span class=\"line\">Constructor getConstructor(Class...&lt;?&gt; paramTypes)：根据参数类型获取类中某个构造器，该构造器必须被public修饰</span><br><span class=\"line\"></span><br><span class=\"line\">Constructor[] getDeclaredConstructors()：获取类中所有构造器</span><br><span class=\"line\"></span><br><span class=\"line\">Constructor getDeclaredConstructor(class...&lt;?&gt; paramTypes)：根据参数类型获取对应的构造器</span><br><span class=\"line\"></span><br><span class=\"line\">Class clazz = Class.forName(&quot;com.bean.SmallPineapple&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">Constructor constructor = clazz.getConstructor(String.class, int.class);</span><br><span class=\"line\"></span><br><span class=\"line\">constructor.setAccessible(true);</span><br><span class=\"line\"></span><br><span class=\"line\">SmallPineapple smallPineapple2 = (SmallPineapple) constructor.newInstance(&quot;小菠萝&quot;, 21);</span><br><span class=\"line\"></span><br><span class=\"line\">smallPineapple2.getInfo();</span><br></pre></td></tr></table></figure>\n\n<p>变量：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Field[] getFields()：获取类中所有被public、protected修饰的所有变量</span><br><span class=\"line\"></span><br><span class=\"line\">Field getField(String name)：根据变量名获取类中的一个变量，获取是被public和protected修饰的</span><br><span class=\"line\"></span><br><span class=\"line\">Field[] getDeclaredFields()：获取类中所有的变量，但无法获取继承下来的变量</span><br><span class=\"line\"></span><br><span class=\"line\">Field getDeclaredField(String name)：根据姓名获取类中的某个变量，无法获取继承下来的变量</span><br></pre></td></tr></table></figure>\n\n<p>方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Method[] getMethods()：获取类中被public、protected修饰的所有方法</span><br><span class=\"line\"></span><br><span class=\"line\">Method getMethod(String name, Class...&lt;?&gt; paramTypes)：根据名字和参数类型获取对应方法，该方法必须被public、protected修饰</span><br><span class=\"line\"></span><br><span class=\"line\">Method[] getDeclaredMethods()：获取所有方法，但无法获取继承下来的方法</span><br><span class=\"line\"></span><br><span class=\"line\">Method getDeclaredMethod(String name, Class...&lt;?&gt; paramTypes)：根据名字和参数类型获取对应方法，无法获取继承下来的方法</span><br></pre></td></tr></table></figure>\n\n<p>注解：只有@Retension为RUNTIME时才能通过反射获取该注解</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Annotation[] getAnnotations()：获取该对象上的所有注解</span><br><span class=\"line\"></span><br><span class=\"line\">Annotation getAnnotation(Class annotaionClass)：传入注解类型，获取该对象上的特定一个注解</span><br><span class=\"line\"></span><br><span class=\"line\">Annotation[] getDeclaredAnnotations()：获取该对象上的显式标注的所有注解，无法获取继承下来的注解</span><br><span class=\"line\"></span><br><span class=\"line\">Annotation getDeclaredAnnotation(Class annotationClass)：根据注解类型，获取该对象上的特定一个注解，无法获取继承下来的注解</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"⑦IO流分几种\"><a href=\"#⑦IO流分几种\" class=\"headerlink\" title=\"⑦IO流分几种\"></a>⑦IO流分几种</h3><p>IO流分为字节流和字符流，与之对应的抽象类有inputstream、outputstream、reader、writer</p>\n<p>字节流可以传递存储任何类型的数据，字符流只能处理字符、字符串，使用指定的字符集进行编码操作</p>\n<p>BIO：同步阻塞式IO  NIO：同步非阻塞 AIO：NIO升级也叫NIO2，异步非阻塞</p>\n<h3 id=\"⑧泛型类型擦除\"><a href=\"#⑧泛型类型擦除\" class=\"headerlink\" title=\"⑧泛型类型擦除\"></a>⑧泛型类型擦除</h3><p>类型擦除发生在编译过程中，所有泛型信息都会被擦除</p>\n<h3 id=\"⑨注解的理解\"><a href=\"#⑨注解的理解\" class=\"headerlink\" title=\"⑨注解的理解\"></a>⑨注解的理解</h3><p>本质：做一个标识，通过这个标识对代码规范、变量值做一些修饰。主要划分为三类</p>\n<table>\n<thead>\n<tr>\n<th>Source</th>\n<th align=\"left\">仅仅存在在.java文件，编译成.class文件就消失了。作用为：让开发者按照注解的规范编写代码。例如：<a href=\"https://github.com/OverRide\">@OverRide</a></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Class</td>\n<td align=\"left\">在前期编译期的流程中，会被处理成.class内容，与原生代码效率几乎相同。<br />作用为：自动生成.class文件，做一些辅助性工作。例如：ButterKnife、GreenDao、ARouter</td>\n<td>效率和原生代码相当</td>\n</tr>\n<tr>\n<td>Runtime</td>\n<td align=\"left\">编译成.class文件之后，依旧以注解的方式存在。而是在运行期生效。<br />作用为：在运行期，通过反射做一些辅助性工作。例如：xUtils</td>\n<td>由于集中使用遍历+反射，因此效率较低。而且在9.0禁用反射</td>\n</tr>\n</tbody></table>\n<h2 id=\"1-2-Java集合\"><a href=\"#1-2-Java集合\" class=\"headerlink\" title=\"1.2 Java集合\"></a>1.2 Java集合</h2><h3 id=\"①list、set、map\"><a href=\"#①list、set、map\" class=\"headerlink\" title=\"①list、set、map\"></a>①list、set、map</h3><p>Iterator是所有集合的总接口，Collection继承于Iterator。list有序可重复，set无序不可重复，map键值对，键唯一。</p>\n<p>list、set继承自collection。ArrayList数组结构，存储地址连续、linkedList双向链表结构。</p>\n<p>hashset哈希表实现，无序可放入null</p>\n<p>treeset是二叉树红黑树结构实现的，自动排序不允许null值</p>\n<p>hashmap hashtable concurrentHashMap、linkedhashmap</p>\n<h2 id=\"1-3-Java多线程\"><a href=\"#1-3-Java多线程\" class=\"headerlink\" title=\"1.3 Java多线程\"></a>1.3 Java多线程</h2><h3 id=\"①-java-多线程的方式\"><a href=\"#①-java-多线程的方式\" class=\"headerlink\" title=\"① java 多线程的方式\"></a>① java 多线程的方式</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 继承Thread，重写run方法，用start启动</span><br><span class=\"line\">2. 自定义runnable，放入thread启动</span><br><span class=\"line\">3.通过线程池、callable、future实现有返回结果的多线程</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"②-线程的状态\"><a href=\"#②-线程的状态\" class=\"headerlink\" title=\"② 线程的状态\"></a>② 线程的状态</h3><ul>\n<li>new 创建状态</li>\n<li>runnable 运行</li>\n<li>blocked 阻塞</li>\n<li>waiting 等待</li>\n<li>timed_waiting 超时等待</li>\n<li>end 终止</li>\n</ul>\n<h3 id=\"③-实现多线程中的同步\"><a href=\"#③-实现多线程中的同步\" class=\"headerlink\" title=\"③ 实现多线程中的同步\"></a>③ 实现多线程中的同步</h3><ul>\n<li><p>volatile 简单逻辑可以实现 简单的 set get</p>\n</li>\n<li><p>synchronized</p>\n</li>\n<li><p>reentrantlock</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. Lock lock = new ReentrantLock();</span><br><span class=\"line\">   try &#123;</span><br><span class=\"line\">            todo.........</span><br><span class=\"line\">        &#125; finally &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">也可以尝试获取锁</span><br><span class=\"line\">if (lock.tryLock(1, TimeUnit.SECONDS)) &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125; finally &#123;</span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">2.配合condition的await和signal模仿obj的wait、notify</span><br><span class=\"line\">3.  ReadWriteLock rwlock = new ReentrantReadWriteLock();</span><br><span class=\"line\">    Lock rlock = rwlock.readLock();</span><br><span class=\"line\">    Lock wlock = rwlock.writeLock();</span><br></pre></td></tr></table></figure></li>\n<li><p>cas   unsafe类</p>\n</li>\n<li><p>Object.wait/notify</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wait属于object类中的方法，调用后释放锁，将当前线程a放入该对象锁的等待池，线程b执行notify会通知等待池，使线程a从等待池进入阻塞队列等到线程b释放锁后线程a竞争锁继续执行。</span><br><span class=\"line\">notifyall会把等待池里所有的线程唤醒去竞争</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"④-线程池\"><a href=\"#④-线程池\" class=\"headerlink\" title=\"④ 线程池\"></a>④ 线程池</h3><ul>\n<li><p>常见线程池</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Executors.newFixedThreadPool 使用的是linkedblockingqueue  指定核心线程数</span><br><span class=\"line\">Executors.newCachedThreadPool 使用的是SynchronousQueue</span><br><span class=\"line\">Executors.newSingleThreadExecutor 使用的是LinkedBlokingQueue</span><br><span class=\"line\">Executors.newScheduledThreadPool</span><br><span class=\"line\"></span><br><span class=\"line\">ThreadPoolExecutor  核心线程数 最大线程数 超时回收时间 时间单位 任务处理队列 线程工厂</span><br></pre></td></tr></table></figure>\n\n<p>核心线程-》阻塞队列-》非核心线程-》handler拒绝任务提交</p>\n</li>\n<li><p>常见的任务处理阻塞队列<br>ArrayBlockingQueue 有界数组阻塞队列<br>LinkedBlockingQueue 无界链表阻塞队列<br>SynchronousQueue 无存储队列<br>PriorityBlockingQueue 优先级阻塞队列</p>\n</li>\n<li><p>shutdown 关闭线程池——等添加到线程池中的任务全部完成才退出<br>shutdownNow  关闭线程池并中断任务  调用Tread.interrupt中断任务 但线程无sleep、wait、condition、定时锁等是无法中断新城，有可能需要等所有线程执行完毕关闭</p>\n</li>\n</ul>\n<h3 id=\"⑤-synchronized与volatile\"><a href=\"#⑤-synchronized与volatile\" class=\"headerlink\" title=\"⑤ synchronized与volatile\"></a>⑤ synchronized与volatile</h3><p>volatile：</p>\n<ol>\n<li>保证变量在不同线程进行操作的可见性</li>\n<li>禁止指令重排<br>指令重排是指指令乱序执行，有时在条件允许情况下，为了避开获取一条指令所需的数据而造成的等待，会通过乱序执行提高效率。添加一个内存屏障，指令乱序时不能把后面的指令排序移到内存屏障之前</li>\n</ol>\n<p>synchronize：</p>\n<p>偏向锁、轻量级锁。自旋锁、重量级锁</p>\n<h3 id=\"⑥-死锁\"><a href=\"#⑥-死锁\" class=\"headerlink\" title=\"⑥ 死锁\"></a>⑥ 死锁</h3><p>当线程a持有独占锁1，并尝试去获取独占锁2的同时，线程b持有独占锁2，并尝试获取独占锁1，这时两个线程都出去获取对方的独占锁处于阻塞状态，产生了死锁。</p>\n<ol>\n<li>互斥条件：一个资源只能被一个线程使用 独占锁</li>\n<li>请求与保持条件：一个线程因请求资源被阻塞，对已获得的资源保持不释放</li>\n<li>不剥夺条件： 线程获得资源在未使用完之前，不能强行剥夺</li>\n<li>循环等待：若干线程之间形成头尾相接的循环资源等待关系</li>\n</ol>\n<p>解决办法：</p>\n<ol>\n<li>加锁顺序控制 按照一定顺序加锁</li>\n<li>加锁时限 线索尝试获取锁时加上时限，超时则放弃对锁的请求，并释放自己占有的锁</li>\n<li>死锁检测 加锁时将线程与锁存在类似map中，每当有线程请求锁失败时可以判断是否有循环锁占有和请求的关系进行处理</li>\n</ol>\n<h3 id=\"⑦-线程、进程\"><a href=\"#⑦-线程、进程\" class=\"headerlink\" title=\"⑦ 线程、进程\"></a>⑦ 线程、进程</h3><p>一个程序至少有一个进程，一个进程至少有一个线程</p>\n<ol>\n<li>进程是资源分配最小单位，线城市程序执行的最小单位。</li>\n<li>进程有自己独立的地址空间，每启动一个进程系统会为其分配地址空间。线程没有独立的地址空间，统一进程的线程共享进程的地址空间</li>\n<li>进程之间资源独立，同一进程内线程共享本晋城资源</li>\n<li>每个独立进程有一个运行入口，顺序执行队列和程序出口。线程不能独立执行，依存于程序进程中</li>\n</ol>\n<h3 id=\"⑧-ThreadLocal\"><a href=\"#⑧-ThreadLocal\" class=\"headerlink\" title=\"⑧ ThreadLocal\"></a>⑧ ThreadLocal</h3><ol>\n<li>原理：<br>每一个tread内部维护了一个threadlocalmap，内部维护了一个数组，数组里面存储的数据是一个entry内部类，key为threadlocal的弱引用，value为我们要存储的数据的强引用。<br>set方法：从当前线程获取他的localthreadmap，根据hashcode与数组长度计算在数组中存储的位置，分为几个情况<br>如果以前在当前位置存储过，更新后返回，发生hash冲突依次向后寻找。返回<br>如果当前key为null，也就是被回收了，会先向前遍历直到entry为空，找到第一个该回收的位置，然后再向后遍历查找是否和当前key匹配的有的话进行位置交换及清理,返回<br>如果没有存储过就直接新建存储，进行清理并检查需不需要扩容；<br>在执行get操作时，从当前线程获取他的localthreadmap，根据threadlocal的hashcode与数组长度计算存储的数组位置，通过当前的threadlocal获取我们存储的值。</li>\n<li>内存泄漏：因为value为强引用，threadlocal回收后未去回收他的value就会发生内存泄漏，不用时应该保证执行remove或保证与线程生命周期相同</li>\n</ol>\n<h2 id=\"1-4-Java内存\"><a href=\"#1-4-Java内存\" class=\"headerlink\" title=\"1.4 Java内存\"></a>1.4 Java内存</h2><h3 id=\"①-类的加载\"><a href=\"#①-类的加载\" class=\"headerlink\" title=\"① 类的加载\"></a>① 类的加载</h3><ul>\n<li>android中有5个类加载器：ClassLoader（所有类加载器的抽象基类）、BootClassLoader（用于加在android系统的类，classloader的内部类，开发者无法调用）、BaseDexClassLoader（继承ClassLoader）、PathClassLoader（继承于BaseDexClassLoader，通常用于加载我们自己写的类含第三方库，但不局限于此）、DexClassLoader（继承于BaseDexClassLoader，通常用于执行动态加载，能够加在指定路径的apk、jar、zip、dex文件，因此很多热修复和插件化方案使用）</li>\n<li>加载时使用双亲委派模式加载，先以递归方式向上级父加载器验证是否已经加载，若没被加载过在从最顶级加载器进行加载操作，加载失败逐级向下进行加载。保证类只会被加载一次。</li>\n<li>加载（通过类的全限定名获取类的二进制字节流，将静态存储结构转化为方法区的运行数据结构，在内存中生成Class对象，作为这个类的各种数据的方位入口）-》<br>连接（1.验证——语法是否通过；2.准备——变量分配内存；3.解析——接口、字段和方法的符号引用转为直接引用）-》<br>初始化（对变量和一些代码块进行初始化及执行）</li>\n</ul>\n<h3 id=\"②-引用类型\"><a href=\"#②-引用类型\" class=\"headerlink\" title=\"② 引用类型\"></a>② 引用类型</h3><ol>\n<li>强引用：垃圾回收器不会回收，及时内存空间不足，jvm宁愿outofmemoryerror程序异常终止也不随意回收强引用对象</li>\n<li>软引用：如果一个对象只有软引用，内存够用的时候不会对其进行回收，当内存不足时hiuduiqijinxinghuishou，可以和引用队列联合使用</li>\n<li>弱引用：如果一个对象只有弱引用，垃圾回收器检测到就会对其进行回收。由于垃圾回收器所在线程优先级很低不一定会快发现，可以和引用队列联合使用</li>\n<li>虚引用：任何时候都可能被回收，主要用于跟踪对象呗垃圾回收器回收的活动。必须与ReferenceQueue联合使用</li>\n</ol>\n<h3 id=\"③-Java内存模型\"><a href=\"#③-Java内存模型\" class=\"headerlink\" title=\"③ Java内存模型\"></a>③ Java内存模型</h3><ol>\n<li>堆  对象</li>\n<li>栈  线程栈帧 线程私有</li>\n<li>本地方发栈</li>\n<li>方法区 加载的类信息、常量、静态变量、即时编译器编译后的代码</li>\n<li>程序计数器</li>\n</ol>\n<h3 id=\"④-Java内存回收机制\"><a href=\"#④-Java内存回收机制\" class=\"headerlink\" title=\"④ Java内存回收机制\"></a>④ Java内存回收机制</h3><ul>\n<li><p>回收检测有两种：<br>引用计数法：有对这个对象的引用+1，不再引用-1<br>可达性分析：以GCRoots对象为起点，从这个节点从上到下搜索，路径称为引用链，当一个对象没有任何引用链与GCRoots连接时，就说明当前对象不可达可以回收<br>GC Roots对象通常包括：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">虚拟机栈中引用的对象——栈帧中的本地变量表</span><br><span class=\"line\">方法中类的静态属性引用的对象</span><br><span class=\"line\">方法区常量引用的对象</span><br><span class=\"line\">Native方法引用的对象</span><br></pre></td></tr></table></figure></li>\n<li><p>回收算法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 标记清除：</span><br><span class=\"line\">   扫描并标记存活目标，标记完成后再扫描未标记的对象对其进行回收。存活对象多时效率高</span><br><span class=\"line\">但是会造成内存碎片。</span><br><span class=\"line\">2. 标记整理：</span><br><span class=\"line\">   在标记清除基础上，将存活的内存进行移动整理更新指针。适合对象存活率高的场景——老</span><br><span class=\"line\">年代回收。</span><br><span class=\"line\">3. 复制：</span><br><span class=\"line\">   将内存分为大小相等两块，每次只是用一块。当内存使用完后，将存活对象复制到另一侧，</span><br><span class=\"line\">再将该区域全部清除。适用于对象存活率低情况——新生代。</span><br><span class=\"line\">4. 分代收集：</span><br><span class=\"line\">   不同的对象生命周期不同，不同的生命周期的对象放置在堆中的不同区域，以不同的策略</span><br><span class=\"line\">进行回收提高效率。新生代使用复制算法；老年代使用标记清除或标记整理。分代收集一般分</span><br><span class=\"line\">为新生代，老年代和永久代。</span><br><span class=\"line\">   新生代：所有新对象首先都放在新生代，按照8：1：1比例分为一个Eden区和两个survivor区。</span><br><span class=\"line\">大部分对象在Eden区生成，回收时先将Eden存活对象复制到survivor0然后清空Eden，</span><br><span class=\"line\">当这survivor0存放满，将Eden区域survivor0中存活的对象复制到survivor1中，</span><br><span class=\"line\">清空Eden与survivor0，然后将survivor0与survivor1互换保证survivor1为空。</span><br><span class=\"line\">当survivor1不足存放时就会将存活对象存放至老年代。若是老年代满了就会出发full GC，</span><br><span class=\"line\">也就是新老年代都进行回收。新生代的GC叫做MinorGC发生频率高。</span><br><span class=\"line\">   老年代： 内存大概是新生代的两倍，老年代中的对象存活时间长。</span><br><span class=\"line\">   永久代： 主要存放静态文件，如java类、方法等。对垃圾回收没有显著影响，用来解决</span><br><span class=\"line\">动态代理或是反射等等运行中新增的类的内存。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"⑤-jvm、dalvik和art\"><a href=\"#⑤-jvm、dalvik和art\" class=\"headerlink\" title=\"⑤ jvm、dalvik和art\"></a>⑤ jvm、dalvik和art</h3><ul>\n<li>jvm：java虚拟机，并不是某个特定虚拟机的实现，而是任何能运行java字节码的虚拟机实现</li>\n<li>dalvik：是google创建的用于android的虚拟机，但其严格来说不算jvm，5.0被art替代<br>基于寄存器，jvm基于堆栈；有自己的字节码不是java字节码；jit即时编译</li>\n<li>art：android run time。4.4-6.0采用安装时全部编译为机器码的方式实现，7.0开始默认不全部编译，采用解释执行+jit+空闲时间aot以改善安装耗时。<br>aot预编译在安装过程中，将所有字节码变异成机器码，运行时直接调用。</li>\n</ul>\n<h1 id=\"2-Kotlin\"><a href=\"#2-Kotlin\" class=\"headerlink\" title=\"2 Kotlin\"></a>2 Kotlin</h1><h2 id=\"2-1-kotlin语言特性\"><a href=\"#2-1-kotlin语言特性\" class=\"headerlink\" title=\"2.1 kotlin语言特性\"></a>2.1 kotlin语言特性</h2><h3 id=\"①-介绍kotlin其特性\"><a href=\"#①-介绍kotlin其特性\" class=\"headerlink\" title=\"① 介绍kotlin其特性\"></a>① 介绍kotlin其特性</h3><ul>\n<li>能与java互相调用</li>\n<li>减少样板代码</li>\n<li>可将kotlin编译为无需虚拟机就可以运行的原生二进制文件</li>\n<li>支持高阶函数</li>\n<li>支持协程</li>\n<li>语言层面解决空指针问题</li>\n<li>对lambda表达式更好地支持</li>\n</ul>\n<h3 id=\"②-JvmOverloads作用\"><a href=\"#②-JvmOverloads作用\" class=\"headerlink\" title=\"② @JvmOverloads作用\"></a>② @JvmOverloads作用</h3><p>在有默认参数值的方法中使用@JvmOverloads注解会重载多个方法。</p>\n<h3 id=\"③-kotlin中单例与java对比\"><a href=\"#③-kotlin中单例与java对比\" class=\"headerlink\" title=\"③ kotlin中单例与java对比\"></a>③ kotlin中单例与java对比</h3><ol>\n<li><p>线程不安全饿汉式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kotlin：</span><br><span class=\"line\">object Single&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">java：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n<li><p>```</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ol>\n<pre><code>\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-Java面试题\"><a href=\"#1-Java面试题\" class=\"headerlink\" title=\"1.Java面试题\"></a>1.Java面试题</h1><h2 id=\"1-1Java基础\"><a href=\"#1-1Java基础\" class=\"headerlink\" title=\"1.1Java基础\"></a>1.1Java基础</h2><h3 id=\"①抽象类与接口区别\"><a href=\"#①抽象类与接口区别\" class=\"headerlink\" title=\"①抽象类与接口区别\"></a>①抽象类与接口区别</h3><ul>\n<li>方法：抽象类可以提供方法的实现，接口中即jdk8以后添加default关键字才可以实现默认实现</li>\n<li>参数：抽象类成员变量可以任意创建，接口只能是public static final修饰的变量</li>\n<li>构造函数：接口不能拥有构造器，静态代码块、静态方法，抽象类可以</li>\n<li>只可继承一个抽象类但是可以实现多个接口</li>\n</ul>\n<p>都不可直接实例化是共同点</p>\n<h3 id=\"②final、static、synchronized可以修饰什么-什么作用\"><a href=\"#②final、static、synchronized可以修饰什么-什么作用\" class=\"headerlink\" title=\"②final、static、synchronized可以修饰什么 什么作用\"></a>②final、static、synchronized可以修饰什么 什么作用</h3><p>final:</p>\n<ul>\n<li>类：说明该类功能已经全面了，不允许继承。String类。Interger</li>\n<li>方法：该方法不可以被子类重写.final方法编译的时候已经静态绑定了</li>\n<li>变量：变量不可变  成员变量或是局部变量修饰可以成为最终变量，配合静态static修饰变量称为常量</li>\n</ul>\n<p>static：</p>\n<ul>\n<li>代码块：类进行加载的时候会按顺序执行</li>\n<li>方法：静态方法属于类的层面，调用的时候用类名.方法名直接调用</li>\n<li>变量：静态变量，存在Java内存模型中的方法区</li>\n<li>内部类：可以直接作为一个普通类使用，不需要先实例化一个外部类实例</li>\n</ul>\n<p>synchronized：</p>\n<ul>\n<li>修饰方法：方法为静态方法为类锁，反之为对象锁</li>\n<li>修饰代码块：锁住的是类为类锁，反之为对象锁</li>\n</ul>\n<h3 id=\"③String、StringBuffer、StringBUilder\"><a href=\"#③String、StringBuffer、StringBUilder\" class=\"headerlink\" title=\"③String、StringBuffer、StringBUilder\"></a>③String、StringBuffer、StringBUilder</h3><p>String为字符串常量，如果要进行拼接+操作，会生成一个新的字符串重新赋予变量，连续拼接操作时会造成一些资源损耗还影响效率</p>\n<p>StringBuilder是线程不安全的字符串拼接工具类，append</p>\n<p>StringBuffer为线程安全的</p>\n<h3 id=\"④equals-hashcode\"><a href=\"#④equals-hashcode\" class=\"headerlink\" title=\"④equals == hashcode\"></a>④equals == hashcode</h3><p>未重写equals等方法时与==一样，对比引用是否一致</p>\n<p>一般equals与hashcode需要统一重写，保证equals为true hashcode必须为true  可反性</p>\n<h3 id=\"⑤Error和Exception区别\"><a href=\"#⑤Error和Exception区别\" class=\"headerlink\" title=\"⑤Error和Exception区别\"></a>⑤Error和Exception区别</h3><p>Error为程序运行时不可预料的错误情况，发生时会直接杀死进程</p>\n<p>Exception为运行中可预料到的异常情况，分为检查性异常与非检查型异常，检查性异常需要在编写代码时使用try catch捕获</p>\n<p>使用throw抛出的是error</p>\n<h3 id=\"⑥什么是反射机制\"><a href=\"#⑥什么是反射机制\" class=\"headerlink\" title=\"⑥什么是反射机制\"></a>⑥什么是反射机制</h3><p>java反射就是在程序运行过程中通过一些类或方法或是变量的信息对其进行获取操作</p>\n<p>获取类信息：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">obj.getClass()</span><br><span class=\"line\">类名.class</span><br><span class=\"line\">Class.forName(&quot;包名+类名&quot;)</span><br></pre></td></tr></table></figure>\n\n<p>构造方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Constuctor[] getConstructors()：获取类中所有被public修饰的构造器</span><br><span class=\"line\"></span><br><span class=\"line\">Constructor getConstructor(Class...&lt;?&gt; paramTypes)：根据参数类型获取类中某个构造器，该构造器必须被public修饰</span><br><span class=\"line\"></span><br><span class=\"line\">Constructor[] getDeclaredConstructors()：获取类中所有构造器</span><br><span class=\"line\"></span><br><span class=\"line\">Constructor getDeclaredConstructor(class...&lt;?&gt; paramTypes)：根据参数类型获取对应的构造器</span><br><span class=\"line\"></span><br><span class=\"line\">Class clazz = Class.forName(&quot;com.bean.SmallPineapple&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">Constructor constructor = clazz.getConstructor(String.class, int.class);</span><br><span class=\"line\"></span><br><span class=\"line\">constructor.setAccessible(true);</span><br><span class=\"line\"></span><br><span class=\"line\">SmallPineapple smallPineapple2 = (SmallPineapple) constructor.newInstance(&quot;小菠萝&quot;, 21);</span><br><span class=\"line\"></span><br><span class=\"line\">smallPineapple2.getInfo();</span><br></pre></td></tr></table></figure>\n\n<p>变量：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Field[] getFields()：获取类中所有被public、protected修饰的所有变量</span><br><span class=\"line\"></span><br><span class=\"line\">Field getField(String name)：根据变量名获取类中的一个变量，获取是被public和protected修饰的</span><br><span class=\"line\"></span><br><span class=\"line\">Field[] getDeclaredFields()：获取类中所有的变量，但无法获取继承下来的变量</span><br><span class=\"line\"></span><br><span class=\"line\">Field getDeclaredField(String name)：根据姓名获取类中的某个变量，无法获取继承下来的变量</span><br></pre></td></tr></table></figure>\n\n<p>方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Method[] getMethods()：获取类中被public、protected修饰的所有方法</span><br><span class=\"line\"></span><br><span class=\"line\">Method getMethod(String name, Class...&lt;?&gt; paramTypes)：根据名字和参数类型获取对应方法，该方法必须被public、protected修饰</span><br><span class=\"line\"></span><br><span class=\"line\">Method[] getDeclaredMethods()：获取所有方法，但无法获取继承下来的方法</span><br><span class=\"line\"></span><br><span class=\"line\">Method getDeclaredMethod(String name, Class...&lt;?&gt; paramTypes)：根据名字和参数类型获取对应方法，无法获取继承下来的方法</span><br></pre></td></tr></table></figure>\n\n<p>注解：只有@Retension为RUNTIME时才能通过反射获取该注解</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Annotation[] getAnnotations()：获取该对象上的所有注解</span><br><span class=\"line\"></span><br><span class=\"line\">Annotation getAnnotation(Class annotaionClass)：传入注解类型，获取该对象上的特定一个注解</span><br><span class=\"line\"></span><br><span class=\"line\">Annotation[] getDeclaredAnnotations()：获取该对象上的显式标注的所有注解，无法获取继承下来的注解</span><br><span class=\"line\"></span><br><span class=\"line\">Annotation getDeclaredAnnotation(Class annotationClass)：根据注解类型，获取该对象上的特定一个注解，无法获取继承下来的注解</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"⑦IO流分几种\"><a href=\"#⑦IO流分几种\" class=\"headerlink\" title=\"⑦IO流分几种\"></a>⑦IO流分几种</h3><p>IO流分为字节流和字符流，与之对应的抽象类有inputstream、outputstream、reader、writer</p>\n<p>字节流可以传递存储任何类型的数据，字符流只能处理字符、字符串，使用指定的字符集进行编码操作</p>\n<p>BIO：同步阻塞式IO  NIO：同步非阻塞 AIO：NIO升级也叫NIO2，异步非阻塞</p>\n<h3 id=\"⑧泛型类型擦除\"><a href=\"#⑧泛型类型擦除\" class=\"headerlink\" title=\"⑧泛型类型擦除\"></a>⑧泛型类型擦除</h3><p>类型擦除发生在编译过程中，所有泛型信息都会被擦除</p>\n<h3 id=\"⑨注解的理解\"><a href=\"#⑨注解的理解\" class=\"headerlink\" title=\"⑨注解的理解\"></a>⑨注解的理解</h3><p>本质：做一个标识，通过这个标识对代码规范、变量值做一些修饰。主要划分为三类</p>\n<table>\n<thead>\n<tr>\n<th>Source</th>\n<th align=\"left\">仅仅存在在.java文件，编译成.class文件就消失了。作用为：让开发者按照注解的规范编写代码。例如：<a href=\"https://github.com/OverRide\">@OverRide</a></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Class</td>\n<td align=\"left\">在前期编译期的流程中，会被处理成.class内容，与原生代码效率几乎相同。<br />作用为：自动生成.class文件，做一些辅助性工作。例如：ButterKnife、GreenDao、ARouter</td>\n<td>效率和原生代码相当</td>\n</tr>\n<tr>\n<td>Runtime</td>\n<td align=\"left\">编译成.class文件之后，依旧以注解的方式存在。而是在运行期生效。<br />作用为：在运行期，通过反射做一些辅助性工作。例如：xUtils</td>\n<td>由于集中使用遍历+反射，因此效率较低。而且在9.0禁用反射</td>\n</tr>\n</tbody></table>\n<h2 id=\"1-2-Java集合\"><a href=\"#1-2-Java集合\" class=\"headerlink\" title=\"1.2 Java集合\"></a>1.2 Java集合</h2><h3 id=\"①list、set、map\"><a href=\"#①list、set、map\" class=\"headerlink\" title=\"①list、set、map\"></a>①list、set、map</h3><p>Iterator是所有集合的总接口，Collection继承于Iterator。list有序可重复，set无序不可重复，map键值对，键唯一。</p>\n<p>list、set继承自collection。ArrayList数组结构，存储地址连续、linkedList双向链表结构。</p>\n<p>hashset哈希表实现，无序可放入null</p>\n<p>treeset是二叉树红黑树结构实现的，自动排序不允许null值</p>\n<p>hashmap hashtable concurrentHashMap、linkedhashmap</p>\n<h2 id=\"1-3-Java多线程\"><a href=\"#1-3-Java多线程\" class=\"headerlink\" title=\"1.3 Java多线程\"></a>1.3 Java多线程</h2><h3 id=\"①-java-多线程的方式\"><a href=\"#①-java-多线程的方式\" class=\"headerlink\" title=\"① java 多线程的方式\"></a>① java 多线程的方式</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 继承Thread，重写run方法，用start启动</span><br><span class=\"line\">2. 自定义runnable，放入thread启动</span><br><span class=\"line\">3.通过线程池、callable、future实现有返回结果的多线程</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"②-线程的状态\"><a href=\"#②-线程的状态\" class=\"headerlink\" title=\"② 线程的状态\"></a>② 线程的状态</h3><ul>\n<li>new 创建状态</li>\n<li>runnable 运行</li>\n<li>blocked 阻塞</li>\n<li>waiting 等待</li>\n<li>timed_waiting 超时等待</li>\n<li>end 终止</li>\n</ul>\n<h3 id=\"③-实现多线程中的同步\"><a href=\"#③-实现多线程中的同步\" class=\"headerlink\" title=\"③ 实现多线程中的同步\"></a>③ 实现多线程中的同步</h3><ul>\n<li><p>volatile 简单逻辑可以实现 简单的 set get</p>\n</li>\n<li><p>synchronized</p>\n</li>\n<li><p>reentrantlock</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. Lock lock = new ReentrantLock();</span><br><span class=\"line\">   try &#123;</span><br><span class=\"line\">            todo.........</span><br><span class=\"line\">        &#125; finally &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">也可以尝试获取锁</span><br><span class=\"line\">if (lock.tryLock(1, TimeUnit.SECONDS)) &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125; finally &#123;</span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">2.配合condition的await和signal模仿obj的wait、notify</span><br><span class=\"line\">3.  ReadWriteLock rwlock = new ReentrantReadWriteLock();</span><br><span class=\"line\">    Lock rlock = rwlock.readLock();</span><br><span class=\"line\">    Lock wlock = rwlock.writeLock();</span><br></pre></td></tr></table></figure></li>\n<li><p>cas   unsafe类</p>\n</li>\n<li><p>Object.wait/notify</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wait属于object类中的方法，调用后释放锁，将当前线程a放入该对象锁的等待池，线程b执行notify会通知等待池，使线程a从等待池进入阻塞队列等到线程b释放锁后线程a竞争锁继续执行。</span><br><span class=\"line\">notifyall会把等待池里所有的线程唤醒去竞争</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"④-线程池\"><a href=\"#④-线程池\" class=\"headerlink\" title=\"④ 线程池\"></a>④ 线程池</h3><ul>\n<li><p>常见线程池</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Executors.newFixedThreadPool 使用的是linkedblockingqueue  指定核心线程数</span><br><span class=\"line\">Executors.newCachedThreadPool 使用的是SynchronousQueue</span><br><span class=\"line\">Executors.newSingleThreadExecutor 使用的是LinkedBlokingQueue</span><br><span class=\"line\">Executors.newScheduledThreadPool</span><br><span class=\"line\"></span><br><span class=\"line\">ThreadPoolExecutor  核心线程数 最大线程数 超时回收时间 时间单位 任务处理队列 线程工厂</span><br></pre></td></tr></table></figure>\n\n<p>核心线程-》阻塞队列-》非核心线程-》handler拒绝任务提交</p>\n</li>\n<li><p>常见的任务处理阻塞队列<br>ArrayBlockingQueue 有界数组阻塞队列<br>LinkedBlockingQueue 无界链表阻塞队列<br>SynchronousQueue 无存储队列<br>PriorityBlockingQueue 优先级阻塞队列</p>\n</li>\n<li><p>shutdown 关闭线程池——等添加到线程池中的任务全部完成才退出<br>shutdownNow  关闭线程池并中断任务  调用Tread.interrupt中断任务 但线程无sleep、wait、condition、定时锁等是无法中断新城，有可能需要等所有线程执行完毕关闭</p>\n</li>\n</ul>\n<h3 id=\"⑤-synchronized与volatile\"><a href=\"#⑤-synchronized与volatile\" class=\"headerlink\" title=\"⑤ synchronized与volatile\"></a>⑤ synchronized与volatile</h3><p>volatile：</p>\n<ol>\n<li>保证变量在不同线程进行操作的可见性</li>\n<li>禁止指令重排<br>指令重排是指指令乱序执行，有时在条件允许情况下，为了避开获取一条指令所需的数据而造成的等待，会通过乱序执行提高效率。添加一个内存屏障，指令乱序时不能把后面的指令排序移到内存屏障之前</li>\n</ol>\n<p>synchronize：</p>\n<p>偏向锁、轻量级锁。自旋锁、重量级锁</p>\n<h3 id=\"⑥-死锁\"><a href=\"#⑥-死锁\" class=\"headerlink\" title=\"⑥ 死锁\"></a>⑥ 死锁</h3><p>当线程a持有独占锁1，并尝试去获取独占锁2的同时，线程b持有独占锁2，并尝试获取独占锁1，这时两个线程都出去获取对方的独占锁处于阻塞状态，产生了死锁。</p>\n<ol>\n<li>互斥条件：一个资源只能被一个线程使用 独占锁</li>\n<li>请求与保持条件：一个线程因请求资源被阻塞，对已获得的资源保持不释放</li>\n<li>不剥夺条件： 线程获得资源在未使用完之前，不能强行剥夺</li>\n<li>循环等待：若干线程之间形成头尾相接的循环资源等待关系</li>\n</ol>\n<p>解决办法：</p>\n<ol>\n<li>加锁顺序控制 按照一定顺序加锁</li>\n<li>加锁时限 线索尝试获取锁时加上时限，超时则放弃对锁的请求，并释放自己占有的锁</li>\n<li>死锁检测 加锁时将线程与锁存在类似map中，每当有线程请求锁失败时可以判断是否有循环锁占有和请求的关系进行处理</li>\n</ol>\n<h3 id=\"⑦-线程、进程\"><a href=\"#⑦-线程、进程\" class=\"headerlink\" title=\"⑦ 线程、进程\"></a>⑦ 线程、进程</h3><p>一个程序至少有一个进程，一个进程至少有一个线程</p>\n<ol>\n<li>进程是资源分配最小单位，线城市程序执行的最小单位。</li>\n<li>进程有自己独立的地址空间，每启动一个进程系统会为其分配地址空间。线程没有独立的地址空间，统一进程的线程共享进程的地址空间</li>\n<li>进程之间资源独立，同一进程内线程共享本晋城资源</li>\n<li>每个独立进程有一个运行入口，顺序执行队列和程序出口。线程不能独立执行，依存于程序进程中</li>\n</ol>\n<h3 id=\"⑧-ThreadLocal\"><a href=\"#⑧-ThreadLocal\" class=\"headerlink\" title=\"⑧ ThreadLocal\"></a>⑧ ThreadLocal</h3><ol>\n<li>原理：<br>每一个tread内部维护了一个threadlocalmap，内部维护了一个数组，数组里面存储的数据是一个entry内部类，key为threadlocal的弱引用，value为我们要存储的数据的强引用。<br>set方法：从当前线程获取他的localthreadmap，根据hashcode与数组长度计算在数组中存储的位置，分为几个情况<br>如果以前在当前位置存储过，更新后返回，发生hash冲突依次向后寻找。返回<br>如果当前key为null，也就是被回收了，会先向前遍历直到entry为空，找到第一个该回收的位置，然后再向后遍历查找是否和当前key匹配的有的话进行位置交换及清理,返回<br>如果没有存储过就直接新建存储，进行清理并检查需不需要扩容；<br>在执行get操作时，从当前线程获取他的localthreadmap，根据threadlocal的hashcode与数组长度计算存储的数组位置，通过当前的threadlocal获取我们存储的值。</li>\n<li>内存泄漏：因为value为强引用，threadlocal回收后未去回收他的value就会发生内存泄漏，不用时应该保证执行remove或保证与线程生命周期相同</li>\n</ol>\n<h2 id=\"1-4-Java内存\"><a href=\"#1-4-Java内存\" class=\"headerlink\" title=\"1.4 Java内存\"></a>1.4 Java内存</h2><h3 id=\"①-类的加载\"><a href=\"#①-类的加载\" class=\"headerlink\" title=\"① 类的加载\"></a>① 类的加载</h3><ul>\n<li>android中有5个类加载器：ClassLoader（所有类加载器的抽象基类）、BootClassLoader（用于加在android系统的类，classloader的内部类，开发者无法调用）、BaseDexClassLoader（继承ClassLoader）、PathClassLoader（继承于BaseDexClassLoader，通常用于加载我们自己写的类含第三方库，但不局限于此）、DexClassLoader（继承于BaseDexClassLoader，通常用于执行动态加载，能够加在指定路径的apk、jar、zip、dex文件，因此很多热修复和插件化方案使用）</li>\n<li>加载时使用双亲委派模式加载，先以递归方式向上级父加载器验证是否已经加载，若没被加载过在从最顶级加载器进行加载操作，加载失败逐级向下进行加载。保证类只会被加载一次。</li>\n<li>加载（通过类的全限定名获取类的二进制字节流，将静态存储结构转化为方法区的运行数据结构，在内存中生成Class对象，作为这个类的各种数据的方位入口）-》<br>连接（1.验证——语法是否通过；2.准备——变量分配内存；3.解析——接口、字段和方法的符号引用转为直接引用）-》<br>初始化（对变量和一些代码块进行初始化及执行）</li>\n</ul>\n<h3 id=\"②-引用类型\"><a href=\"#②-引用类型\" class=\"headerlink\" title=\"② 引用类型\"></a>② 引用类型</h3><ol>\n<li>强引用：垃圾回收器不会回收，及时内存空间不足，jvm宁愿outofmemoryerror程序异常终止也不随意回收强引用对象</li>\n<li>软引用：如果一个对象只有软引用，内存够用的时候不会对其进行回收，当内存不足时hiuduiqijinxinghuishou，可以和引用队列联合使用</li>\n<li>弱引用：如果一个对象只有弱引用，垃圾回收器检测到就会对其进行回收。由于垃圾回收器所在线程优先级很低不一定会快发现，可以和引用队列联合使用</li>\n<li>虚引用：任何时候都可能被回收，主要用于跟踪对象呗垃圾回收器回收的活动。必须与ReferenceQueue联合使用</li>\n</ol>\n<h3 id=\"③-Java内存模型\"><a href=\"#③-Java内存模型\" class=\"headerlink\" title=\"③ Java内存模型\"></a>③ Java内存模型</h3><ol>\n<li>堆  对象</li>\n<li>栈  线程栈帧 线程私有</li>\n<li>本地方发栈</li>\n<li>方法区 加载的类信息、常量、静态变量、即时编译器编译后的代码</li>\n<li>程序计数器</li>\n</ol>\n<h3 id=\"④-Java内存回收机制\"><a href=\"#④-Java内存回收机制\" class=\"headerlink\" title=\"④ Java内存回收机制\"></a>④ Java内存回收机制</h3><ul>\n<li><p>回收检测有两种：<br>引用计数法：有对这个对象的引用+1，不再引用-1<br>可达性分析：以GCRoots对象为起点，从这个节点从上到下搜索，路径称为引用链，当一个对象没有任何引用链与GCRoots连接时，就说明当前对象不可达可以回收<br>GC Roots对象通常包括：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">虚拟机栈中引用的对象——栈帧中的本地变量表</span><br><span class=\"line\">方法中类的静态属性引用的对象</span><br><span class=\"line\">方法区常量引用的对象</span><br><span class=\"line\">Native方法引用的对象</span><br></pre></td></tr></table></figure></li>\n<li><p>回收算法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 标记清除：</span><br><span class=\"line\">   扫描并标记存活目标，标记完成后再扫描未标记的对象对其进行回收。存活对象多时效率高</span><br><span class=\"line\">但是会造成内存碎片。</span><br><span class=\"line\">2. 标记整理：</span><br><span class=\"line\">   在标记清除基础上，将存活的内存进行移动整理更新指针。适合对象存活率高的场景——老</span><br><span class=\"line\">年代回收。</span><br><span class=\"line\">3. 复制：</span><br><span class=\"line\">   将内存分为大小相等两块，每次只是用一块。当内存使用完后，将存活对象复制到另一侧，</span><br><span class=\"line\">再将该区域全部清除。适用于对象存活率低情况——新生代。</span><br><span class=\"line\">4. 分代收集：</span><br><span class=\"line\">   不同的对象生命周期不同，不同的生命周期的对象放置在堆中的不同区域，以不同的策略</span><br><span class=\"line\">进行回收提高效率。新生代使用复制算法；老年代使用标记清除或标记整理。分代收集一般分</span><br><span class=\"line\">为新生代，老年代和永久代。</span><br><span class=\"line\">   新生代：所有新对象首先都放在新生代，按照8：1：1比例分为一个Eden区和两个survivor区。</span><br><span class=\"line\">大部分对象在Eden区生成，回收时先将Eden存活对象复制到survivor0然后清空Eden，</span><br><span class=\"line\">当这survivor0存放满，将Eden区域survivor0中存活的对象复制到survivor1中，</span><br><span class=\"line\">清空Eden与survivor0，然后将survivor0与survivor1互换保证survivor1为空。</span><br><span class=\"line\">当survivor1不足存放时就会将存活对象存放至老年代。若是老年代满了就会出发full GC，</span><br><span class=\"line\">也就是新老年代都进行回收。新生代的GC叫做MinorGC发生频率高。</span><br><span class=\"line\">   老年代： 内存大概是新生代的两倍，老年代中的对象存活时间长。</span><br><span class=\"line\">   永久代： 主要存放静态文件，如java类、方法等。对垃圾回收没有显著影响，用来解决</span><br><span class=\"line\">动态代理或是反射等等运行中新增的类的内存。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"⑤-jvm、dalvik和art\"><a href=\"#⑤-jvm、dalvik和art\" class=\"headerlink\" title=\"⑤ jvm、dalvik和art\"></a>⑤ jvm、dalvik和art</h3><ul>\n<li>jvm：java虚拟机，并不是某个特定虚拟机的实现，而是任何能运行java字节码的虚拟机实现</li>\n<li>dalvik：是google创建的用于android的虚拟机，但其严格来说不算jvm，5.0被art替代<br>基于寄存器，jvm基于堆栈；有自己的字节码不是java字节码；jit即时编译</li>\n<li>art：android run time。4.4-6.0采用安装时全部编译为机器码的方式实现，7.0开始默认不全部编译，采用解释执行+jit+空闲时间aot以改善安装耗时。<br>aot预编译在安装过程中，将所有字节码变异成机器码，运行时直接调用。</li>\n</ul>\n<h1 id=\"2-Kotlin\"><a href=\"#2-Kotlin\" class=\"headerlink\" title=\"2 Kotlin\"></a>2 Kotlin</h1><h2 id=\"2-1-kotlin语言特性\"><a href=\"#2-1-kotlin语言特性\" class=\"headerlink\" title=\"2.1 kotlin语言特性\"></a>2.1 kotlin语言特性</h2><h3 id=\"①-介绍kotlin其特性\"><a href=\"#①-介绍kotlin其特性\" class=\"headerlink\" title=\"① 介绍kotlin其特性\"></a>① 介绍kotlin其特性</h3><ul>\n<li>能与java互相调用</li>\n<li>减少样板代码</li>\n<li>可将kotlin编译为无需虚拟机就可以运行的原生二进制文件</li>\n<li>支持高阶函数</li>\n<li>支持协程</li>\n<li>语言层面解决空指针问题</li>\n<li>对lambda表达式更好地支持</li>\n</ul>\n<h3 id=\"②-JvmOverloads作用\"><a href=\"#②-JvmOverloads作用\" class=\"headerlink\" title=\"② @JvmOverloads作用\"></a>② @JvmOverloads作用</h3><p>在有默认参数值的方法中使用@JvmOverloads注解会重载多个方法。</p>\n<h3 id=\"③-kotlin中单例与java对比\"><a href=\"#③-kotlin中单例与java对比\" class=\"headerlink\" title=\"③ kotlin中单例与java对比\"></a>③ kotlin中单例与java对比</h3><ol>\n<li><p>线程不安全饿汉式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kotlin：</span><br><span class=\"line\">object Single&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">java：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n<li><p>```</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ol>\n<pre><code>\n</code></pre>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cl3lbac1u0001rgtq21x8g952","category_id":"cl3lbac1z0003rgtqfln4fqrf","_id":"cl3lbac210005rgtq9wb89ppk"},{"post_id":"cl3lbac250006rgtq4a5jdny4","category_id":"cl3lbac1z0003rgtqfln4fqrf","_id":"cl3lbac260007rgtq7g3gdnxe"}],"PostTag":[],"Tag":[]}}
