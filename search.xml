<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android内存优化</title>
    <url>/2022/06/20/Android%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="一、Android内存管理机制"><a href="#一、Android内存管理机制" class="headerlink" title="一、Android内存管理机制"></a>一、Android内存管理机制</h1><h2 id="1-Java对象生命周期"><a href="#1-Java对象生命周期" class="headerlink" title="1.Java对象生命周期"></a>1.Java对象生命周期</h2><span id="more"></span>


<ul>
<li>Created</li>
<li>Inuse——此时对象<strong>至少被一个强引用持有</strong></li>
<li>Invisible——对象仍然存在但程序中接下来不再持有该对象的任何强引用。</li>
<li>UNreachable——不再被任何强引用持有</li>
<li>Collected——当<strong>GC已经对该对象的内存空间重新分配做好准备</strong>时，对象进入收集阶段，如果该对象重写了finalize()方法，则执行它。</li>
<li>Finalized——<strong>等待垃圾回收器回收该对象空间</strong>。</li>
<li>Deallocated——GC对该对象所占用的内存空间 <strong>进行回收或者再分配</strong> ，则该对象彻底消失。</li>
</ul>
<h2 id="2-Java内存模型"><a href="#2-Java内存模型" class="headerlink" title="2.Java内存模型"></a>2.Java内存模型</h2><p>JVM将整个内存分为五块：</p>
<ol>
<li>方法区：存储类信息、常量、静态变量。所有线程共享。</li>
<li>jvm栈：存储局部变量表，操作数栈等。</li>
<li>本地方法栈：存储的native方法使用的变量。</li>
<li>堆：内存中最大的区域，每一个对象实际分配内存都是在堆上进行分配的。所有线程共享。</li>
<li>程序计数器：存储当前当前线程执行目标方法执行的位置。</li>
</ol>
<h2 id="3-Java内存回收算法"><a href="#3-Java内存回收算法" class="headerlink" title="3.Java内存回收算法"></a>3.Java内存回收算法</h2><p>1.标记-清除算法</p>
<ul>
<li>扫描并标记需要回收的对象</li>
<li>统一回收所有标记的对象</li>
</ul>
<p>缺点是会产生内存碎片</p>
<p>2.复制算法</p>
<ul>
<li>内存分为相等的两个区域</li>
<li>一块区域使用完后将存活的对象复制至另一块</li>
<li>复制后清理该区域</li>
</ul>
<p>缺点是空间浪费</p>
<p>3.标记-整理</p>
<ul>
<li>扫描并标记需要回收的对象</li>
<li>存活对象移动到另一端</li>
<li>清理其余内存</li>
</ul>
<p>避免了标记清除的内存碎片问题也减少了内存浪费</p>
<p>4.分带收集算法</p>
<ul>
<li>结合了多种收集算法的优势，根据不同分代采用不同策略</li>
<li>新生代对象存活率低，采用复制算法</li>
<li>老年代存活率高，采用标记清除算法或者标记整理算法。</li>
</ul>
<p>分代收集一般分为新生代、老年代和永久代。新生代一般是刚创建的对象及回收次数未达到老年代的对象；老年代中对象生命周期都比较长；永久代存放静态的类和方法，在jdk1.8及以后，在本地内存中实现元空间代替永久代。</p>
<p>新生代空间分为Eden区和两个survivor区，回收逻辑如下：</p>
<ul>
<li>对象首先创建在Eden区</li>
<li>Eden区进行GC操作后，将存活对象复制到s0</li>
<li>当s0区满时，该区域存活对象复制到s1区，将s0清空，再将s0与s1角色互换</li>
<li>当survivor区中对象回收次数达到一定次数后，会移动到老年代</li>
</ul>
<h2 id="4-Dalvik与ART区别"><a href="#4-Dalvik与ART区别" class="headerlink" title="4.Dalvik与ART区别"></a>4.Dalvik与ART区别</h2><ul>
<li>Dalvik固定使用一种回收算法</li>
<li>ART回收算法可运行时选择</li>
<li>ART具备内存整理能力，减少内存空间</li>
</ul>
<h1 id="二、内存优化"><a href="#二、内存优化" class="headerlink" title="二、内存优化"></a>二、内存优化</h1><h2 id="1-内存泄漏的常见场景"><a href="#1-内存泄漏的常见场景" class="headerlink" title="1.内存泄漏的常见场景"></a>1.内存泄漏的常见场景</h2><p>Android系统虚拟机的垃圾回收是通过虚拟机GC机制来实现的。GC会选择一些还存活的对象作为内存遍历的根节点GC Roots，通过对GC Roots的可达性来判断是否需要回收。内存泄漏就是 <strong>在当前应用周期内不再使用的对象被GC Roots引用，导致不能回收，使实际可使用内存变小</strong> 。</p>
<ol>
<li>资源对象未关闭<br>例如输入输出流未关闭、数据库使用完未关闭等</li>
<li>注册对象为注销<br>例如BraodcastReceiver、EventBus未注销造成的内存泄漏，我们应该在Activity销毁时及时注销。</li>
<li>该回收的对象被静态引用</li>
<li>非静态内部类</li>
<li>该回收对象被数组等引用</li>
<li>webview<br>WebView都存在内存泄漏的问题，在应用中只要使用一次WebView，内存就不会被释放掉。</li>
</ol>
<h2 id="2-内存泄露的监控"><a href="#2-内存泄露的监控" class="headerlink" title="2.内存泄露的监控"></a>2.内存泄露的监控</h2><p>一般使用LeakCanary进行内存泄漏的监控，大致原理如下：</p>
<p>目前最新版本仅用debugImplementation就可以实现内存泄漏监听。这是利用了ContentProVider进行初始化，在应用启动时回调他的oncreate方法。在oncreate方法里面进行他的多种watcher的安装。内部创建对于activity、fragmentAndViewModel、rootView、service的watcher，并依次进行install操作。</p>
<p>ContentProVider的oncreate在于application的oncreate（handleBindApplication），</p>
<p>晚于application的attachBaseContext。</p>
<p>先进性对应该回收对象的生命周期加入钩子。</p>
<ol>
<li>ActivityWatcher会在install操作中通过by noOpDelegate委托生成动态代理 application.registerActivityLifecycleCallbacks对其进行onActivityDestroyed监听，当activity调用ondestroyed时会进行内部ObjectWatcher的expectWeaklyReachable方法，检查五秒后是否被回收，未被回收则标记内存泄漏。</li>
<li>FragmentAndViewModelWatcher在开始与ActivityWatcher一样，不过是注册activity的onactivityCreated监听。在oncreate的时候对他的fragmentwatcher数组依次进行。</li>
<li>RootViewWatcher是使用Curtains的onRootViewsChangedListeners，在detached的时候验证</li>
<li>ServiceWatcher是通过反射activityThread拿到mservices，对activityThread中的handler的mcallback进行动态代理，在service真正destroy的时候进行验证</li>
</ol>
<p>ObjectWatcher进行对象的是否内存泄漏检查：</p>
<ol>
<li>先移除已被回收的对象</li>
<li>用UUID生成一个key，然后同观察对象、描述、引用队列等创建弱引用。并根据key将reference存入map里。</li>
<li>在默认5s延迟后再清理一遍，检测对象是否被回收</li>
<li>没有回收调用onObjectRetainedListener</li>
</ol>
<p>objectRetainedListener里面主要执行heapDumpTrigger的一些方法</p>
<ol>
<li>首先判断是否有异常持有的对象，有的话触发Gc操作，没有就返回</li>
<li>如果还有异常判断泄露数量是否达到dump</li>
<li>达到的话会进行dumpHeap</li>
<li>然后使用HeapAnalyzerService，启动shark分析</li>
<li>读取hprof内存快照文件</li>
<li>找到leakCanary标记的泄露对象的数量和弱引用包装的ids</li>
<li>找到gcRoot开始的路径</li>
</ol>
<h2 id="3-优化内存空间"><a href="#3-优化内存空间" class="headerlink" title="3.优化内存空间"></a>3.优化内存空间</h2><h3 id="1-对象引用"><a href="#1-对象引用" class="headerlink" title="1.对象引用"></a>1.对象引用</h3><ul>
<li>强引用：代码中普遍存在的，只要强引用还存在，垃圾收集器就不会回收掉被引用的对象。</li>
<li>软引用：SoftReference，用来描述还有用但是非必须的对象，当内存不足的时候会回收这类对象。</li>
<li>弱引用：WeakReference，用来描述非必须对象，弱引用的对象只能生存到下一次 GC 发生时，当 GC 发生时，无论内存是否足够，都会回收该对象。</li>
<li>虚引用：PhantomReference，一个对象是否有虚引用的存在，完全不会对其生存时间产生影响，也无法通过虚引用取得一个对象的引用，它存在的唯一目的是在这个对象被回收时可以收到一个系统通知。</li>
</ul>
<p>举个例子，单例工具类在使用一些activity或context，可以通过弱引用进行按相关操作。</p>
<h3 id="2-AutoBoxing"><a href="#2-AutoBoxing" class="headerlink" title="2.AutoBoxing"></a>2.AutoBoxing</h3><p>自动装箱的核心就是把基础数据类型转换成对应的复杂类型。在自动装箱转化时，都会产生一个新的对象，这样就会产生更多的内存和性能开销。如int只占4字节，而Integer对象有16字节，特别是HashMap这类容器，进行增、删、改、查操作时，都会产生大量的自动装箱操作。</p>
<p>在数据量千级以内的情况下</p>
<ul>
<li>如果 key 的类型已经确定为 int 类型，那么使用 SparseArray，因为它避免了自动装箱的过程，如果 key 为 long 类型，它还提供了一个 LongSparseArray 来确保 key 为 long 类型时的使用</li>
<li>如果 key 类型为其它的类型，则使用 ArrayMap。</li>
</ul>
<h3 id="3-LruCache"><a href="#3-LruCache" class="headerlink" title="3.LruCache"></a>3.LruCache</h3><p>最近最少使用缓存，使用强引用保存需要缓存的对象，它内部维护了一个由LinkedHashMap组成的双向列表，不支持线程安全，LruCache对它进行了封装，添加了线程安全操作。当其中的一个值被访问时，它被放到队列的尾部，当缓存将满时，队列头部的值（最近最少被访问的）被丢弃，之后可以被GC回收。</p>
<p>除了普通的get/set方法之外，还有sizeOf方法，它用来返回每个缓存对象的大小。此外，还有entryRemoved方法，当一个缓存对象被丢弃时调用的方法，当第一个参数为true：表明缓存对象是为了腾出空间而被清理。否则，表明缓存对象的entry是被remove移除或者被put覆盖。</p>
<p>注意：分配LruCache大小时应考虑应用剩余内存有多大。</p>
<h3 id="4-图片内存优化"><a href="#4-图片内存优化" class="headerlink" title="4.图片内存优化"></a>4.图片内存优化</h3><p>在Android默认情况下，当图片文件解码成位图时，会被处理成32bit/像素。红色、绿色、蓝色和透明通道各8bit，即使是没有透明通道的图片，如JEPG隔世是没有透明通道的，但然后会处理成32bit位图，这样分配的32bit中的8bit透明通道数据是没有任何用处的，这完全没有必要，并且在这些图片被屏幕渲染之前，它们首先要被作为纹理传送到GPU，这意味着每一张图片会同时占用CPU内存和GPU内存。下面，我总结了减少内存开销的几种常用方式，如下所示：</p>
<p>1、设置位图的规格：当显示小图片或对图片质量要求不高时可以考虑使用RGB_565，用户头像或圆角图片一般可以尝试ARGB_4444。通过设置inPreferredConfig参数来实现不同的位图规格，代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BitmapFactory.Options options = new BitmapFactory.Options();</span><br><span class="line">options.inPreferredConfig = Bitmap.Config.RGB_565;</span><br><span class="line">BitmapFactory.decodeStream(is, null, options);</span><br></pre></td></tr></table></figure>

<p>2、inSampleSize：位图功能对象中的inSampleSize属性实现了位图的缩放功能，代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BitampFactory.Options options = new BitmapFactory.Options();</span><br><span class="line">// 设置为4就是宽和高都变为原来1/4大小的图片</span><br><span class="line">options.inSampleSize = 4;</span><br><span class="line">BitmapFactory.decodeSream(is, null, options);</span><br></pre></td></tr></table></figure>

<p>3、inScaled，inDensity和inTargetDensity实现更细的缩放图片：当inScaled设置为true时，系统会按照现有的密度来划分目标密度，代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BitampFactory.Options options = new BitampFactory.Options();</span><br><span class="line">options.inScaled = true;</span><br><span class="line">options.inDensity = srcWidth;</span><br><span class="line">options.inTargetDensity = dstWidth;</span><br><span class="line">BitmapFactory.decodeStream(is, null, options);</span><br></pre></td></tr></table></figure>

<p>上述三种方案的缺点：使用了过多的算法，导致图片显示过程需要更多的时间开销，如果图片很多的话，就影响到图片的显示效果。最好的方案是结合这两个方法，达到最佳的性能结合，首先使用inSampleSize处理图片，转换为接近目标的2次幂，然后用inDensity和inTargetDensity生成最终想要的准确大小，因为inSampleSize会减少像素的数量，而基于输出密码的需要对像素重新过滤。但获取资源图片的大小，需要设置位图对象的inJustDecodeBounds值为true，然后继续解码图片文件，这样才能生产图片的宽高数据，并允许继续优化图片。总体的代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BitmapFactory.Options options = new BitampFactory.Options();</span><br><span class="line">options.inJustDecodeBounds = true;</span><br><span class="line">BitmapFactory.decodeStream(is, null, options);</span><br><span class="line">options.inScaled = true;</span><br><span class="line">options.inDensity = options.outWidth;</span><br><span class="line">options.inSampleSize = 4;</span><br><span class="line">Options.inTargetDensity = desWith * options.inSampleSize;</span><br><span class="line">options.inJustDecodeBounds = false;</span><br><span class="line">BitmapFactory.decodeStream(is, null, options);</span><br></pre></td></tr></table></figure>

<p>4、图片放置优化</p>
<p>只需要UI提供一套高分辨率的图，图片建议放在drawable-xxhdpi文件夹下，这样在低分辨率设备中图片的大小只是压缩，不会存在内存增大的情况。如若遇到不需缩放的文件，放在drawable-nodpi文件夹下。</p>
<p>5、在App可用内存过低时主动释放内存</p>
<p>在App退到后台内存紧张即将被Kill掉时选择重写 onTrimMemory/onLowMemory 方法去释放掉图片缓存、静态缓存来自保。</p>
<p>6、item被回收不可见时释放掉对图片的引用</p>
<ul>
<li><strong>ListView</strong> ：因此每次item被回收后再次利用都会重新绑定数据，只需在ImageView onDetachFromWindow的时候释放掉图片引用即可。</li>
<li><strong>RecyclerView</strong> ：因为被回收不可见时第一选择是放进mCacheView中，这里item被复用并不会只需bindViewHolder来重新绑定数据，只有被回收进mRecyclePool中后拿出来复用才会重新绑定数据，因此重写Recycler.Adapter中的onViewRecycled()方法来使item被回收进RecyclePool的时候去释放图片引用。</li>
</ul>
<p>7、避免创作不必要的对象</p>
<p>例如，我们可以在字符串拼接的时候使用StringBuffer，StringBuilder。</p>
<p>8、自定义View中的内存优化</p>
<p>例如，在onDraw方法里面不要执行对象的创建，一般来说，都应该在自定义View的构造器中创建对象。</p>
<p>9、其它的内存优化注意事项</p>
<p>除了上面的一些内存优化点之外，这里还有一些内存优化的点我们需要注意，如下所示：</p>
<ul>
<li>尽使用static final 优化成员变量。</li>
<li>使用增强型for循环语法。</li>
<li>在没有特殊原因的情况下，尽量使用基本数据类型来代替封装数据类型，int比Integer要更加有效，其它数据类型也是一样。</li>
<li>在合适的时候适当采用软引用和弱引用。</li>
<li>采用内存缓存和磁盘缓存。</li>
<li>尽量采用静态内部类，可避免潜在由于内部类导致的内存泄漏。</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
        <category>Android</category>
        <category>优化</category>
      </categories>
      <tags>
        <tag>Android优化</tag>
      </tags>
  </entry>
  <entry>
    <title>ReactNative交互</title>
    <url>/2022/01/18/ReactNative%E4%BA%A4%E4%BA%92/</url>
    <content><![CDATA[<p>React Native与Android原生交互主要涉及三个方面：1.原生调用rn方法；2.rn调用原生方法；3.rn使用原生自定义组件</p>
<h1 id="Android调用RN方法"><a href="#Android调用RN方法" class="headerlink" title="Android调用RN方法"></a>Android调用RN方法</h1><ol>
<li><p>rn注册事件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const &#123;EventEmitterManager&#125; = NativeModules;</span><br><span class="line">const tempEventEmitterManager = new NativeEventEmitter(EventEmitterManager);</span><br><span class="line"></span><br><span class="line">this.remoteNoti = tempEventEmitterManager.addListener(</span><br><span class="line">            &#x27;CustomEvent&#x27;,</span><br><span class="line">            (e)=&gt;this.androidEvent(e));</span><br></pre></td></tr></table></figure></li>
<li><p>android发送事件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义发送事件的函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendEvent</span><span class="params">(ReactContext reactContext, String eventName, WritableMap params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  reactContext.getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class).emit(eventName,params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="RN调用android方法"><a href="#RN调用android方法" class="headerlink" title="RN调用android方法"></a>RN调用android方法</h1><ol>
<li><p>首先要创建自定义模块<br>一般创建继承于<code>ReactContextBaseJavaModule</code>的类来进行模块方法的封装。实现<code>getName</code>，返回的是rn中使用的模块名。具体供rn调用的方法上使用<code>@ReactMethod</code>标注。官方的例子创建一个toast工具类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToastModule</span> <span class="keyword">extends</span> <span class="title">ReactContextBaseJavaModule</span> </span>&#123;  <span class="keyword">private</span> <span class="keyword">static</span> ReactApplicationContext reactContext;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ToastModule</span><span class="params">(ReactApplicationContext context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(context);</span><br><span class="line">    reactContext = context;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;ToastExample&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@ReactMethod</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String message, <span class="keyword">int</span> duration)</span> </span>&#123;</span><br><span class="line">    Toast.makeText(getReactApplicationContext(), message, duration).show();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内部还提供了一个可选方法<code>getConstants()</code>，可以给JavaScript提供使用的常量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DURATION_SHORT_KEY = <span class="string">&quot;SHORT&quot;</span>;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DURATION_LONG_KEY = <span class="string">&quot;LONG&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getConstants</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> Map&lt;String, Object&gt; constants = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">   constants.put(DURATION_SHORT_KEY, Toast.LENGTH_SHORT);</span><br><span class="line">   constants.put(DURATION_LONG_KEY, Toast.LENGTH_LONG);</span><br><span class="line">   <span class="keyword">return</span> constants;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>注册自定义模块<br>之后我们要创建一个自定义的Package，并要在Package类的<code>createNativeModules</code>方法中添加创建的模块。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomToastPackage</span> <span class="keyword">implements</span> <span class="title">ReactPackage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//这里添加自定义view</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;ViewManager&gt; <span class="title">createViewManagers</span><span class="params">(ReactApplicationContext reactContext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;NativeModule&gt; <span class="title">createNativeModules</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">                              ReactApplicationContext reactContext)</span> </span>&#123;</span><br><span class="line">    List&lt;NativeModule&gt; modules = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    modules.add(<span class="keyword">new</span> ToastModule(reactContext));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> modules;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后在ReactNativeHost里getPackages添加我们的customPackage</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReactApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> <span class="keyword">implements</span> <span class="title">ReactApplication</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        SoLoader.init(<span class="keyword">this</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReactNativeHost mReactNativeHost = <span class="keyword">new</span> ReactNativeHost(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getUseDeveloperSupport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> BuildConfig.DEBUG;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> List&lt;ReactPackage&gt; <span class="title">getPackages</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Arrays.&lt;ReactPackage&gt;asList(<span class="keyword">new</span> CustomToastPackage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ReactNativeHost <span class="title">getReactNativeHost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mReactNativeHost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在RN中使用<br>实现了上述步骤后就完成了在RN中自定义模块的注册，名为我们之前<code>getName</code>返回的字符串。之前传递的可选常量可以使用<code>ToastExample.SHORT</code>进行使用。我们可以在RN中使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import ToastExample from &#x27;../NativeModules/ToastExample&#x27;</span><br><span class="line"></span><br><span class="line">ToastExample.show（&quot;Something&quot;,ToastExample.SHORT`）</span><br></pre></td></tr></table></figure></li>
<li><p>自定义回调参数，并使用Callback返回结果<br>这里先引入一个<code>@ReactMethod</code>方法中，参数类型与他们对应JavaScript类型的映射表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Boolean -&gt; Bool</span><br><span class="line">Integer -&gt; Number</span><br><span class="line">Double -&gt; Number</span><br><span class="line">Float -&gt; Number</span><br><span class="line">String -&gt; String</span><br><span class="line">Callback -&gt; function</span><br><span class="line">ReadableMap -&gt; Object</span><br><span class="line">ReadableArray -&gt; Array</span><br></pre></td></tr></table></figure>

<p>JS调用时传递的function在执行原生方法时会转变成Callback</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ReactMethod</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendRequest</span><span class="params">(String message, Callback success, Callback failture)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String parma1 = message;</span><br><span class="line">        String parma2 = <span class="string">&quot;收到回调信息&quot;</span>;            <span class="comment">// 回调成功，返回结果信息</span></span><br><span class="line">        success.invoke(parma1, parma2);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (IllegalViewOperationException e) &#123;            <span class="comment">// 回调失败，返回错误信息</span></span><br><span class="line">        failture.invoke(e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>相应的RN代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CustomModule.sendRequest(</span><br><span class="line">    <span class="string">&quot;这是带Callback回调的函数方法&quot;</span>,</span><br><span class="line">     (parma1, parma2) =&gt; &#123;</span><br><span class="line">        <span class="keyword">var</span> result = parma1 + parma2;</span><br><span class="line">        console.log(result);</span><br><span class="line">    &#125;,</span><br><span class="line">    errMsg =&gt; &#123;</span><br><span class="line">        console.log(errMsg);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>导出带参函数并使用Promises返回结果<br>RN提供一个桥接方法最后一个参数为Promise,可以使用async/await获取执行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UIManagerModule</span> <span class="keyword">extends</span> <span class="title">ReactContextBaseJavaModule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String E_LAYOUT_ERROR = <span class="string">&quot;E_LAYOUT_ERROR&quot;</span>;</span><br><span class="line">  <span class="meta">@ReactMethod</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">measureLayout</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">int</span> tag,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">int</span> ancestorTag,</span></span></span><br><span class="line"><span class="params"><span class="function">      Promise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      measureLayout(tag, ancestorTag, mMeasureBuffer);</span><br><span class="line"></span><br><span class="line">      WritableMap map = Arguments.createMap();</span><br><span class="line"></span><br><span class="line">      map.putDouble(<span class="string">&quot;relativeX&quot;</span>, PixelUtil.toDIPFromPixel(mMeasureBuffer[<span class="number">0</span>]));</span><br><span class="line">      map.putDouble(<span class="string">&quot;relativeY&quot;</span>, PixelUtil.toDIPFromPixel(mMeasureBuffer[<span class="number">1</span>]));</span><br><span class="line">      map.putDouble(<span class="string">&quot;width&quot;</span>, PixelUtil.toDIPFromPixel(mMeasureBuffer[<span class="number">2</span>]));</span><br><span class="line">      map.putDouble(<span class="string">&quot;height&quot;</span>, PixelUtil.toDIPFromPixel(mMeasureBuffer[<span class="number">3</span>]));</span><br><span class="line"></span><br><span class="line">      promise.resolve(map);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalViewOperationException e) &#123;</span><br><span class="line">      promise.reject(E_LAYOUT_ERROR, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>相应的RN方法为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">async function measureLayout() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    const &#123;</span><br><span class="line">      relativeX,</span><br><span class="line">      relativeY,</span><br><span class="line">      width,</span><br><span class="line">      height</span><br><span class="line">    &#125; = await UIManager.measureLayout(100, 100);</span><br><span class="line"></span><br><span class="line">    console.log(</span><br><span class="line">      relativeX + &#x27;:&#x27; + relativeY + &#x27;:&#x27; + width + &#x27;:&#x27; + height</span><br><span class="line">    );</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    console.error(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">measureLayout();</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="自定义视图组件"><a href="#自定义视图组件" class="headerlink" title="自定义视图组件"></a>自定义视图组件</h1><p>整体流程与上面的自定义原生模块很相似。</p>
<ol>
<li><p>创建自定义视图组件<br>创建的自定义UI需要被一个ViewManager或SimpleViewManager的派生类创建管理。一个SimpleViewManager的子类包含背景色、透明度、flexbox等公共属性。每一个子类都是一个单例类。他们被NativeViewHierarchyManager所管理，在合适的时候会委托生成UI组件去更新相应的视图属性。ViewManager还会代理原生视图的所有委托，在适当的时候向RN发送对应的事件通知。下面引用官方的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReactImageManager</span> <span class="keyword">extends</span> <span class="title">SimpleViewManager</span>&lt;<span class="title">ReactImageView</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String REACT_CLASS = <span class="string">&quot;RCTImageView&quot;</span>;</span><br><span class="line">  ReactApplicationContext mCallerContext;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ReactImageManager</span><span class="params">(ReactApplicationContext reactContext)</span> </span>&#123;</span><br><span class="line">    mCallerContext = reactContext;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> REACT_CLASS;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>实现方法<code>createViewInstance</code>返回view实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ReactImageView <span class="title">createViewInstance</span><span class="params">(ThemedReactContext context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ReactImageView(context, Fresco.newDraweeControllerBuilder(), <span class="keyword">null</span>, mCallerContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>@ReactProp</code>或是<code>@ReactPropGroup</code>的注解来导出属性的设置方法。要导出给 JavaScript 使用的属性，需要申明带有<code>@ReactProp</code>（或<code>@ReactPropGroup</code>）注解的设置方法。方法的第一个参数是要修改属性的视图实例，第二个参数是要设置的属性值。方法的返回值类型必须为<code>void</code>，而且访问控制必须被声明为<code>public</code>。JavaScript 所得知的属性类型会由该方法第二个参数的类型来自动决定。支持的类型有：<code>boolean</code>, <code>int</code>, <code>float</code>, <code>double</code>, <code>String</code>, <code>Boolean</code>, <code>Integer</code>, <code>ReadableArray</code>, <code>ReadableMap</code>。<br>除了<code>name</code>，<code>@ReactProp</code>注解还接受这些可选的参数：<code>defaultBoolean</code>, <code>defaultInt</code>, <code>defaultFloat</code>。这些参数必须是对应的基础类型的值（也就是<code>boolean</code>, <code>int</code>, <code>float</code>），这些值会被传递给 setter 方法，以免 JavaScript 端某些情况下在组件中移除了对应的属性。注意这个”默认”值只对基本类型生效，对于其他的类型而言，当对应的属性删除时，<code>null</code>会作为默认值提供给方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ReactProp(name = &quot;src&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSrc</span><span class="params">(ReactImageView view, <span class="meta">@Nullable</span> ReadableArray sources)</span> </span>&#123;</span><br><span class="line">  view.setSource(sources);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ReactProp(name = &quot;borderRadius&quot;, defaultFloat = 0f)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBorderRadius</span><span class="params">(ReactImageView view, <span class="keyword">float</span> borderRadius)</span> </span>&#123;</span><br><span class="line">  view.setBorderRadius(borderRadius);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ReactProp(name = ViewProps.RESIZE_MODE)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResizeMode</span><span class="params">(ReactImageView view, <span class="meta">@Nullable</span> String resizeMode)</span> </span>&#123;</span><br><span class="line">  view.setScaleType(ImageResizeMode.toScaleType(resizeMode));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>事件的处理</p>
<p>现在我们已经知道了怎么导出一个原生视图组件，并且我们可以在 JS 里很方便的控制它了。不过我们怎么才能处理来自用户的事件，譬如缩放操作或者拖动？当一个原生事件发生的时候，它应该也能触发 JavaScript 端视图上的事件，这两个视图会依据<code>getId()</code>而关联在一起。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCustomView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceiveNativeEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      WritableMap event = Arguments.createMap();</span><br><span class="line">      event.putString(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;MyMessage&quot;</span>);</span><br><span class="line">      ReactContext reactContext = (ReactContext)getContext();</span><br><span class="line">      reactContext.getJSModule(RCTEventEmitter.class).receiveEvent(</span><br><span class="line">          getId(),</span><br><span class="line">          <span class="string">&quot;topChange&quot;</span>,</span><br><span class="line">          event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要把事件名<code>topChange</code>映射到 JavaScript 端的<code>onChange</code>回调属性上，需要在你的<code>ViewManager</code>中覆盖<code>getExportedCustomBubblingEventTypeConstants</code>方法，并在其中进行注册：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReactImageManager</span> <span class="keyword">extends</span> <span class="title">SimpleViewManager</span>&lt;<span class="title">MyCustomView</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map <span class="title">getExportedCustomBubblingEventTypeConstants</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> MapBuilder.builder()</span><br><span class="line">            .put(</span><br><span class="line">                <span class="string">&quot;topChange&quot;</span>,</span><br><span class="line">                MapBuilder.of(</span><br><span class="line">                    <span class="string">&quot;phasedRegistrationNames&quot;</span>,</span><br><span class="line">                    MapBuilder.of(<span class="string">&quot;bubbled&quot;</span>, <span class="string">&quot;onChange&quot;</span>)))</span><br><span class="line">                    .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>android端<br><code>reactContext.getJSModule(RCTEventEmitter.class).receiveEvent(yourView.getId(), &quot;topChange&quot;, event);</code><br>receiveEvent第一个参数是viewId，第二个参数是eventName，topChange对应JS接收属性为onChange，第三个参数是需要传递的event。</p>
</li>
<li><p>注册UI组件<br>在之前Package类<code>createNativeModules</code>中的<code>createViewManagers</code>添加我们的UIManager</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;ViewManager&gt; <span class="title">createViewManagers</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">                          ReactApplicationContext reactContext)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Arrays.&lt;ViewManager&gt;asList(</span><br><span class="line">    <span class="keyword">new</span> ReactImageManager(reactContext)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>RN中的使用<br>直接引用方式为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ImageView.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; requireNativeComponent &#125; from <span class="string">&#x27;react-native&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Composes `View`.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * - src: string</span></span><br><span class="line"><span class="comment"> * - borderRadius: number</span></span><br><span class="line"><span class="comment"> * - resizeMode: &#x27;cover&#x27; | &#x27;contain&#x27; | &#x27;stretch&#x27;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">module</span>.<span class="keyword">exports</span> = requireNativeComponent(<span class="string">&#x27;RCTImageView&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p><code>requireNativeComponent</code>目前只接受一个参数，即原生视图的名字。如果你还需要做一些复杂的逻辑譬如事件处理，那么可以把原生组件用一个普通 React 组件封装。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MyCustomView.js</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCustomView</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>._onChange = <span class="keyword">this</span>._onChange.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  _onChange(event: Event) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.props.onChangeMessage) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.props.onChangeMessage(event.nativeEvent.message);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;RCTMyCustomView</span><br><span class="line">        &#123;...<span class="keyword">this</span>.props&#125;</span><br><span class="line">        onChange=&#123;<span class="keyword">this</span>._onChange&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> RCTMyCustomView = requireNativeComponent(`RCTMyCustomView`);</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>ReactNative</tag>
      </tags>
  </entry>
  <entry>
    <title>ReactNative关键函数</title>
    <url>/2021/11/18/ReactNative%E5%85%B3%E9%94%AE%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="getDefaultProps"><a href="#getDefaultProps" class="headerlink" title="getDefaultProps"></a>getDefaultProps</h1><p>在组件创建之前，会先调用 getDefaultProps()，这是全局调用一次，严格地来说，这不是组件的生命周期的一部分。在组件被创建并加载候，首先调用 constructor（以前是getInitialState()），来初始化组件的状态。</p>
<h1 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h1><p>constructor将在任意一个RN组件被加载之前优先调用，并且只会调用一次。该函数最大的作用是定义该组件当中需要使用的状态机变量 。</p>
<h1 id="componentWillMount"><a href="#componentWillMount" class="headerlink" title="componentWillMount"></a>componentWillMount</h1><p>该函数整个过程中只执行一次，该函数会在初始渲染前执行，即在render被调用之前调用，该函数执行后render就会调用。子组件中同样拥有该方法，并会在父组件执行完毕后执行，该函数无返回值。</p>
<p>该函数适合于需要在本地读取一些数据用于显示，那么在render执行前调用是一个很好的时机。</p>
<h1 id="render"><a href="#render" class="headerlink" title="render"></a>render</h1><p>主要负责布局的维护</p>
<h1 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a>componentDidMount</h1><p>该函数会在render渲染完毕之后调用，整个过程只执行一次。</p>
<p>该函数执行后，开发者就可以对界面上的组件或者子组件进行各种操作了。</p>
<p>该函数的应用场景适用于在移动端应用启动之后需要访问网络进行某些数据获取。</p>
<h1 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount"></a>componentWillUnmount</h1><p>该方法会在RN卸载之前调用，无参无返回值，在该方法中，需要对该组件当中申请或者订阅的某些资源与消息进行释放。</p>
<p>在该方法中执行任何必要的清理，比如无效的定时器，或者清除在 componentDidMount 中创建的 DOM 元素。</p>
<h1 id="componentWillReceiveProps"><a href="#componentWillReceiveProps" class="headerlink" title="componentWillReceiveProps"></a>componentWillReceiveProps</h1><p><code>void componentWillReceiveProps(  object nextProps)</code></p>
<p>在这个方法中旧的属性还可以通过<code>this.props</code>获取，可以进行一些setState操作</p>
<h1 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h1><p><code>boolean shouldComponentUpdate(  object nextProps, object nextState )</code></p>
<p>该方法初始化时不会执行，当props或state发生变化时执行。如果不需要更新组件返回false便不会去执行render。</p>
<h1 id="componentWillUpdate"><a href="#componentWillUpdate" class="headerlink" title="componentWillUpdate"></a>componentWillUpdate</h1><p><code>void componentWillUpdate(  object nextProps, object nextState)</code></p>
<p>初始化render时不会执行。当props和state变化时执行，不可以在该方法里<code>this.setState</code>。该方法调用之后就会将最新的props与state写入，再进行render。</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>ReactNative</tag>
      </tags>
  </entry>
</search>
