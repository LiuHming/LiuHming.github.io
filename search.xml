<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ReactNative交互</title>
    <url>/2022/06/18/ReactNative%E4%BA%A4%E4%BA%92/</url>
    <content><![CDATA[<p>React Native与Android原生交互主要涉及三个方面：1.原生调用rn方法；2.rn调用原生方法；3.rn使用原生自定义组件</p>
<h1 id="Android调用RN方法"><a href="#Android调用RN方法" class="headerlink" title="Android调用RN方法"></a>Android调用RN方法</h1><ol>
<li><p>rn注册事件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const &#123;EventEmitterManager&#125; = NativeModules;</span><br><span class="line">const tempEventEmitterManager = new NativeEventEmitter(EventEmitterManager);</span><br><span class="line"></span><br><span class="line">this.remoteNoti = tempEventEmitterManager.addListener(</span><br><span class="line">            &#x27;CustomEvent&#x27;,</span><br><span class="line">            (e)=&gt;this.androidEvent(e));</span><br></pre></td></tr></table></figure></li>
<li><p>android发送事件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义发送事件的函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendEvent</span><span class="params">(ReactContext reactContext, String eventName, WritableMap params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  reactContext.getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class).emit(eventName,params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="RN调用android方法"><a href="#RN调用android方法" class="headerlink" title="RN调用android方法"></a>RN调用android方法</h1><ol>
<li><p>首先要创建自定义模块<br>一般创建继承于<code>ReactContextBaseJavaModule</code>的类来进行模块方法的封装。实现<code>getName</code>，返回的是rn中使用的模块名。具体供rn调用的方法上使用<code>@ReactMethod</code>标注。官方的例子创建一个toast工具类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToastModule</span> <span class="keyword">extends</span> <span class="title">ReactContextBaseJavaModule</span> </span>&#123;  <span class="keyword">private</span> <span class="keyword">static</span> ReactApplicationContext reactContext;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ToastModule</span><span class="params">(ReactApplicationContext context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(context);</span><br><span class="line">    reactContext = context;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;ToastExample&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@ReactMethod</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String message, <span class="keyword">int</span> duration)</span> </span>&#123;</span><br><span class="line">    Toast.makeText(getReactApplicationContext(), message, duration).show();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内部还提供了一个可选方法<code>getConstants()</code>，可以给JavaScript提供使用的常量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DURATION_SHORT_KEY = <span class="string">&quot;SHORT&quot;</span>;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DURATION_LONG_KEY = <span class="string">&quot;LONG&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getConstants</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> Map&lt;String, Object&gt; constants = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">   constants.put(DURATION_SHORT_KEY, Toast.LENGTH_SHORT);</span><br><span class="line">   constants.put(DURATION_LONG_KEY, Toast.LENGTH_LONG);</span><br><span class="line">   <span class="keyword">return</span> constants;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>注册自定义模块<br>之后我们要创建一个自定义的Package，并要在Package类的<code>createNativeModules</code>方法中添加创建的模块。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomToastPackage</span> <span class="keyword">implements</span> <span class="title">ReactPackage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//这里添加自定义view</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;ViewManager&gt; <span class="title">createViewManagers</span><span class="params">(ReactApplicationContext reactContext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;NativeModule&gt; <span class="title">createNativeModules</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">                              ReactApplicationContext reactContext)</span> </span>&#123;</span><br><span class="line">    List&lt;NativeModule&gt; modules = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    modules.add(<span class="keyword">new</span> ToastModule(reactContext));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> modules;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后在ReactNativeHost里getPackages添加我们的customPackage</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReactApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> <span class="keyword">implements</span> <span class="title">ReactApplication</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        SoLoader.init(<span class="keyword">this</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReactNativeHost mReactNativeHost = <span class="keyword">new</span> ReactNativeHost(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getUseDeveloperSupport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> BuildConfig.DEBUG;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> List&lt;ReactPackage&gt; <span class="title">getPackages</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Arrays.&lt;ReactPackage&gt;asList(<span class="keyword">new</span> CustomToastPackage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ReactNativeHost <span class="title">getReactNativeHost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mReactNativeHost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在RN中使用<br>实现了上述步骤后就完成了在RN中自定义模块的注册，名为我们之前<code>getName</code>返回的字符串。之前传递的可选常量可以使用<code>ToastExample.SHORT</code>进行使用。我们可以在RN中使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import ToastExample from &#x27;../NativeModules/ToastExample&#x27;</span><br><span class="line"></span><br><span class="line">ToastExample.show（&quot;Something&quot;,ToastExample.SHORT`）</span><br></pre></td></tr></table></figure></li>
<li><p>自定义回调参数，并使用Callback返回结果<br>这里先引入一个<code>@ReactMethod</code>方法中，参数类型与他们对应JavaScript类型的映射表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Boolean -&gt; Bool</span><br><span class="line">Integer -&gt; Number</span><br><span class="line">Double -&gt; Number</span><br><span class="line">Float -&gt; Number</span><br><span class="line">String -&gt; String</span><br><span class="line">Callback -&gt; function</span><br><span class="line">ReadableMap -&gt; Object</span><br><span class="line">ReadableArray -&gt; Array</span><br></pre></td></tr></table></figure>

<p>JS调用时传递的function在执行原生方法时会转变成Callback</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ReactMethod</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendRequest</span><span class="params">(String message, Callback success, Callback failture)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String parma1 = message;</span><br><span class="line">        String parma2 = <span class="string">&quot;收到回调信息&quot;</span>;            <span class="comment">// 回调成功，返回结果信息</span></span><br><span class="line">        success.invoke(parma1, parma2);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (IllegalViewOperationException e) &#123;            <span class="comment">// 回调失败，返回错误信息</span></span><br><span class="line">        failture.invoke(e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>相应的RN代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CustomModule.sendRequest(</span><br><span class="line">    <span class="string">&quot;这是带Callback回调的函数方法&quot;</span>,</span><br><span class="line">     (parma1, parma2) =&gt; &#123;</span><br><span class="line">        <span class="keyword">var</span> result = parma1 + parma2;</span><br><span class="line">        console.log(result);</span><br><span class="line">    &#125;,</span><br><span class="line">    errMsg =&gt; &#123;</span><br><span class="line">        console.log(errMsg);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>导出带参函数并使用Promises返回结果<br>RN提供一个桥接方法最后一个参数为Promise,可以使用async/await获取执行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UIManagerModule</span> <span class="keyword">extends</span> <span class="title">ReactContextBaseJavaModule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String E_LAYOUT_ERROR = <span class="string">&quot;E_LAYOUT_ERROR&quot;</span>;</span><br><span class="line">  <span class="meta">@ReactMethod</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">measureLayout</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">int</span> tag,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">int</span> ancestorTag,</span></span></span><br><span class="line"><span class="params"><span class="function">      Promise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      measureLayout(tag, ancestorTag, mMeasureBuffer);</span><br><span class="line"></span><br><span class="line">      WritableMap map = Arguments.createMap();</span><br><span class="line"></span><br><span class="line">      map.putDouble(<span class="string">&quot;relativeX&quot;</span>, PixelUtil.toDIPFromPixel(mMeasureBuffer[<span class="number">0</span>]));</span><br><span class="line">      map.putDouble(<span class="string">&quot;relativeY&quot;</span>, PixelUtil.toDIPFromPixel(mMeasureBuffer[<span class="number">1</span>]));</span><br><span class="line">      map.putDouble(<span class="string">&quot;width&quot;</span>, PixelUtil.toDIPFromPixel(mMeasureBuffer[<span class="number">2</span>]));</span><br><span class="line">      map.putDouble(<span class="string">&quot;height&quot;</span>, PixelUtil.toDIPFromPixel(mMeasureBuffer[<span class="number">3</span>]));</span><br><span class="line"></span><br><span class="line">      promise.resolve(map);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalViewOperationException e) &#123;</span><br><span class="line">      promise.reject(E_LAYOUT_ERROR, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>相应的RN方法为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">async function measureLayout() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    const &#123;</span><br><span class="line">      relativeX,</span><br><span class="line">      relativeY,</span><br><span class="line">      width,</span><br><span class="line">      height</span><br><span class="line">    &#125; = await UIManager.measureLayout(100, 100);</span><br><span class="line"></span><br><span class="line">    console.log(</span><br><span class="line">      relativeX + &#x27;:&#x27; + relativeY + &#x27;:&#x27; + width + &#x27;:&#x27; + height</span><br><span class="line">    );</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    console.error(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">measureLayout();</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="自定义视图组件"><a href="#自定义视图组件" class="headerlink" title="自定义视图组件"></a>自定义视图组件</h1><p>整体流程与上面的自定义原生模块很相似。</p>
<ol>
<li><p>创建自定义视图组件<br>创建的自定义UI需要被一个ViewManager或SimpleViewManager的派生类创建管理。一个SimpleViewManager的子类包含背景色、透明度、flexbox等公共属性。每一个子类都是一个单例类。他们被NativeViewHierarchyManager所管理，在合适的时候会委托生成UI组件去更新相应的视图属性。ViewManager还会代理原生视图的所有委托，在适当的时候向RN发送对应的事件通知。下面引用官方的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReactImageManager</span> <span class="keyword">extends</span> <span class="title">SimpleViewManager</span>&lt;<span class="title">ReactImageView</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String REACT_CLASS = <span class="string">&quot;RCTImageView&quot;</span>;</span><br><span class="line">  ReactApplicationContext mCallerContext;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ReactImageManager</span><span class="params">(ReactApplicationContext reactContext)</span> </span>&#123;</span><br><span class="line">    mCallerContext = reactContext;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> REACT_CLASS;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>实现方法<code>createViewInstance</code>返回view实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ReactImageView <span class="title">createViewInstance</span><span class="params">(ThemedReactContext context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ReactImageView(context, Fresco.newDraweeControllerBuilder(), <span class="keyword">null</span>, mCallerContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>@ReactProp</code>或是<code>@ReactPropGroup</code>的注解来导出属性的设置方法。要导出给 JavaScript 使用的属性，需要申明带有<code>@ReactProp</code>（或<code>@ReactPropGroup</code>）注解的设置方法。方法的第一个参数是要修改属性的视图实例，第二个参数是要设置的属性值。方法的返回值类型必须为<code>void</code>，而且访问控制必须被声明为<code>public</code>。JavaScript 所得知的属性类型会由该方法第二个参数的类型来自动决定。支持的类型有：<code>boolean</code>, <code>int</code>, <code>float</code>, <code>double</code>, <code>String</code>, <code>Boolean</code>, <code>Integer</code>, <code>ReadableArray</code>, <code>ReadableMap</code>。<br>除了<code>name</code>，<code>@ReactProp</code>注解还接受这些可选的参数：<code>defaultBoolean</code>, <code>defaultInt</code>, <code>defaultFloat</code>。这些参数必须是对应的基础类型的值（也就是<code>boolean</code>, <code>int</code>, <code>float</code>），这些值会被传递给 setter 方法，以免 JavaScript 端某些情况下在组件中移除了对应的属性。注意这个”默认”值只对基本类型生效，对于其他的类型而言，当对应的属性删除时，<code>null</code>会作为默认值提供给方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ReactProp(name = &quot;src&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSrc</span><span class="params">(ReactImageView view, <span class="meta">@Nullable</span> ReadableArray sources)</span> </span>&#123;</span><br><span class="line">  view.setSource(sources);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ReactProp(name = &quot;borderRadius&quot;, defaultFloat = 0f)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBorderRadius</span><span class="params">(ReactImageView view, <span class="keyword">float</span> borderRadius)</span> </span>&#123;</span><br><span class="line">  view.setBorderRadius(borderRadius);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ReactProp(name = ViewProps.RESIZE_MODE)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResizeMode</span><span class="params">(ReactImageView view, <span class="meta">@Nullable</span> String resizeMode)</span> </span>&#123;</span><br><span class="line">  view.setScaleType(ImageResizeMode.toScaleType(resizeMode));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>事件的处理</p>
<p>现在我们已经知道了怎么导出一个原生视图组件，并且我们可以在 JS 里很方便的控制它了。不过我们怎么才能处理来自用户的事件，譬如缩放操作或者拖动？当一个原生事件发生的时候，它应该也能触发 JavaScript 端视图上的事件，这两个视图会依据<code>getId()</code>而关联在一起。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCustomView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceiveNativeEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      WritableMap event = Arguments.createMap();</span><br><span class="line">      event.putString(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;MyMessage&quot;</span>);</span><br><span class="line">      ReactContext reactContext = (ReactContext)getContext();</span><br><span class="line">      reactContext.getJSModule(RCTEventEmitter.class).receiveEvent(</span><br><span class="line">          getId(),</span><br><span class="line">          <span class="string">&quot;topChange&quot;</span>,</span><br><span class="line">          event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要把事件名<code>topChange</code>映射到 JavaScript 端的<code>onChange</code>回调属性上，需要在你的<code>ViewManager</code>中覆盖<code>getExportedCustomBubblingEventTypeConstants</code>方法，并在其中进行注册：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReactImageManager</span> <span class="keyword">extends</span> <span class="title">SimpleViewManager</span>&lt;<span class="title">MyCustomView</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map <span class="title">getExportedCustomBubblingEventTypeConstants</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> MapBuilder.builder()</span><br><span class="line">            .put(</span><br><span class="line">                <span class="string">&quot;topChange&quot;</span>,</span><br><span class="line">                MapBuilder.of(</span><br><span class="line">                    <span class="string">&quot;phasedRegistrationNames&quot;</span>,</span><br><span class="line">                    MapBuilder.of(<span class="string">&quot;bubbled&quot;</span>, <span class="string">&quot;onChange&quot;</span>)))</span><br><span class="line">                    .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>android端<br><code>reactContext.getJSModule(RCTEventEmitter.class).receiveEvent(yourView.getId(), &quot;topChange&quot;, event);</code><br>receiveEvent第一个参数是viewId，第二个参数是eventName，topChange对应JS接收属性为onChange，第三个参数是需要传递的event。</p>
</li>
<li><p>注册UI组件<br>在之前Package类<code>createNativeModules</code>中的<code>createViewManagers</code>添加我们的UIManager</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;ViewManager&gt; <span class="title">createViewManagers</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">                          ReactApplicationContext reactContext)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Arrays.&lt;ViewManager&gt;asList(</span><br><span class="line">    <span class="keyword">new</span> ReactImageManager(reactContext)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>RN中的使用<br>直接引用方式为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ImageView.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; requireNativeComponent &#125; from <span class="string">&#x27;react-native&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Composes `View`.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * - src: string</span></span><br><span class="line"><span class="comment"> * - borderRadius: number</span></span><br><span class="line"><span class="comment"> * - resizeMode: &#x27;cover&#x27; | &#x27;contain&#x27; | &#x27;stretch&#x27;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">module</span>.<span class="keyword">exports</span> = requireNativeComponent(<span class="string">&#x27;RCTImageView&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p><code>requireNativeComponent</code>目前只接受一个参数，即原生视图的名字。如果你还需要做一些复杂的逻辑譬如事件处理，那么可以把原生组件用一个普通 React 组件封装。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MyCustomView.js</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCustomView</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>._onChange = <span class="keyword">this</span>._onChange.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  _onChange(event: Event) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.props.onChangeMessage) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.props.onChangeMessage(event.nativeEvent.message);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;RCTMyCustomView</span><br><span class="line">        &#123;...<span class="keyword">this</span>.props&#125;</span><br><span class="line">        onChange=&#123;<span class="keyword">this</span>._onChange&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> RCTMyCustomView = requireNativeComponent(`RCTMyCustomView`);</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>ReactNative</tag>
      </tags>
  </entry>
  <entry>
    <title>ReactNative关键函数</title>
    <url>/2022/06/18/ReactNative%E5%85%B3%E9%94%AE%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="getDefaultProps"><a href="#getDefaultProps" class="headerlink" title="getDefaultProps"></a>getDefaultProps</h1><p>在组件创建之前，会先调用 getDefaultProps()，这是全局调用一次，严格地来说，这不是组件的生命周期的一部分。在组件被创建并加载候，首先调用 constructor（以前是getInitialState()），来初始化组件的状态。</p>
<h1 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h1><p>constructor将在任意一个RN组件被加载之前优先调用，并且只会调用一次。该函数最大的作用是定义该组件当中需要使用的状态机变量 。</p>
<h1 id="componentWillMount"><a href="#componentWillMount" class="headerlink" title="componentWillMount"></a>componentWillMount</h1><p>该函数整个过程中只执行一次，该函数会在初始渲染前执行，即在render被调用之前调用，该函数执行后render就会调用。子组件中同样拥有该方法，并会在父组件执行完毕后执行，该函数无返回值。</p>
<p>该函数适合于需要在本地读取一些数据用于显示，那么在render执行前调用是一个很好的时机。</p>
<h1 id="render"><a href="#render" class="headerlink" title="render"></a>render</h1><p>主要负责布局的维护</p>
<h1 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a>componentDidMount</h1><p>该函数会在render渲染完毕之后调用，整个过程只执行一次。</p>
<p>该函数执行后，开发者就可以对界面上的组件或者子组件进行各种操作了。</p>
<p>该函数的应用场景适用于在移动端应用启动之后需要访问网络进行某些数据获取。</p>
<h1 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount"></a>componentWillUnmount</h1><p>该方法会在RN卸载之前调用，无参无返回值，在该方法中，需要对该组件当中申请或者订阅的某些资源与消息进行释放。</p>
<p>在该方法中执行任何必要的清理，比如无效的定时器，或者清除在 componentDidMount 中创建的 DOM 元素。</p>
<h1 id="componentWillReceiveProps"><a href="#componentWillReceiveProps" class="headerlink" title="componentWillReceiveProps"></a>componentWillReceiveProps</h1><p><code>void componentWillReceiveProps(  object nextProps)</code></p>
<p>在这个方法中旧的属性还可以通过<code>this.props</code>获取，可以进行一些setState操作</p>
<h1 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h1><p><code>boolean shouldComponentUpdate(  object nextProps, object nextState )</code></p>
<p>该方法初始化时不会执行，当props或state发生变化时执行。如果不需要更新组件返回false便不会去执行render。</p>
<h1 id="componentWillUpdate"><a href="#componentWillUpdate" class="headerlink" title="componentWillUpdate"></a>componentWillUpdate</h1><p><code>void componentWillUpdate(  object nextProps, object nextState)</code></p>
<p>初始化render时不会执行。当props和state变化时执行，不可以在该方法里<code>this.setState</code>。该方法调用之后就会将最新的props与state写入，再进行render。</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>ReactNative</tag>
      </tags>
  </entry>
  <entry>
    <title>Android内存优化</title>
    <url>/2022/06/20/Android%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="一、Android内存管理机制"><a href="#一、Android内存管理机制" class="headerlink" title="一、Android内存管理机制"></a>一、Android内存管理机制</h1><h2 id="1-Java对象生命周期"><a href="#1-Java对象生命周期" class="headerlink" title="1.Java对象生命周期"></a>1.Java对象生命周期</h2><span id="more"></span>


<ul>
<li>Created</li>
<li>Inuse——此时对象<strong>至少被一个强引用持有</strong></li>
<li>Invisible——对象仍然存在但程序中接下来不再持有该对象的任何强引用。</li>
<li>UNreachable——不再被任何强引用持有</li>
<li>Collected——当<strong>GC已经对该对象的内存空间重新分配做好准备</strong>时，对象进入收集阶段，如果该对象重写了finalize()方法，则执行它。</li>
<li>Finalized——<strong>等待垃圾回收器回收该对象空间</strong>。</li>
<li>Deallocated——GC对该对象所占用的内存空间 <strong>进行回收或者再分配</strong> ，则该对象彻底消失。</li>
</ul>
<h2 id="2-Java内存模型"><a href="#2-Java内存模型" class="headerlink" title="2.Java内存模型"></a>2.Java内存模型</h2><p>JVM将整个内存分为五块：</p>
<ol>
<li>方法区：存储类信息、常量、静态变量。所有线程共享。</li>
<li>jvm栈：存储局部变量表，操作数栈等。</li>
<li>本地方法栈：存储的native方法使用的变量。</li>
<li>堆：内存中最大的区域，每一个对象实际分配内存都是在堆上进行分配的。所有线程共享。</li>
<li>程序计数器：存储当前当前线程执行目标方法执行的位置。</li>
</ol>
<h2 id="3-Java内存回收算法"><a href="#3-Java内存回收算法" class="headerlink" title="3.Java内存回收算法"></a>3.Java内存回收算法</h2><p>1.标记-清除算法</p>
<ul>
<li>扫描并标记需要回收的对象</li>
<li>统一回收所有标记的对象</li>
</ul>
<p>缺点是会产生内存碎片</p>
<p>2.复制算法</p>
<ul>
<li>内存分为相等的两个区域</li>
<li>一块区域使用完后将存活的对象复制至另一块</li>
<li>复制后清理该区域</li>
</ul>
<p>缺点是空间浪费</p>
<p>3.标记-整理</p>
<ul>
<li>扫描并标记需要回收的对象</li>
<li>存活对象移动到另一端</li>
<li>清理其余内存</li>
</ul>
<p>避免了标记清除的内存碎片问题也减少了内存浪费</p>
<p>4.分带收集算法</p>
<ul>
<li>结合了多种收集算法的优势，根据不同分代采用不同策略</li>
<li>新生代对象存活率低，采用复制算法</li>
<li>老年代存活率高，采用标记清除算法或者标记整理算法。</li>
</ul>
<p>分代收集一般分为新生代、老年代和永久代。新生代一般是刚创建的对象及回收次数未达到老年代的对象；老年代中对象生命周期都比较长；永久代存放静态的类和方法，在jdk1.8及以后，在本地内存中实现元空间代替永久代。</p>
<p>新生代空间分为Eden区和两个survivor区，回收逻辑如下：</p>
<ul>
<li>对象首先创建在Eden区</li>
<li>Eden区进行GC操作后，将存活对象复制到s0</li>
<li>当s0区满时，该区域存活对象复制到s1区，将s0清空，再将s0与s1角色互换</li>
<li>当survivor区中对象回收次数达到一定次数后，会移动到老年代</li>
</ul>
<h2 id="4-Dalvik与ART区别"><a href="#4-Dalvik与ART区别" class="headerlink" title="4.Dalvik与ART区别"></a>4.Dalvik与ART区别</h2><ul>
<li>Dalvik固定使用一种回收算法</li>
<li>ART回收算法可运行时选择</li>
<li>ART具备内存整理能力，减少内存空间</li>
</ul>
<h1 id="二、内存优化"><a href="#二、内存优化" class="headerlink" title="二、内存优化"></a>二、内存优化</h1><h2 id="1-内存泄漏的常见场景"><a href="#1-内存泄漏的常见场景" class="headerlink" title="1.内存泄漏的常见场景"></a>1.内存泄漏的常见场景</h2><p>Android系统虚拟机的垃圾回收是通过虚拟机GC机制来实现的。GC会选择一些还存活的对象作为内存遍历的根节点GC Roots，通过对GC Roots的可达性来判断是否需要回收。内存泄漏就是 <strong>在当前应用周期内不再使用的对象被GC Roots引用，导致不能回收，使实际可使用内存变小</strong> 。</p>
<ol>
<li>资源对象未关闭<br>例如输入输出流未关闭、数据库使用完未关闭等</li>
<li>注册对象为注销<br>例如BraodcastReceiver、EventBus未注销造成的内存泄漏，我们应该在Activity销毁时及时注销。</li>
<li>该回收的对象被静态引用</li>
<li>非静态内部类</li>
<li>该回收对象被数组等引用</li>
<li>webview<br>WebView都存在内存泄漏的问题，在应用中只要使用一次WebView，内存就不会被释放掉。</li>
</ol>
<h2 id="2-内存泄露的监控"><a href="#2-内存泄露的监控" class="headerlink" title="2.内存泄露的监控"></a>2.内存泄露的监控</h2><p>一般使用LeakCanary进行内存泄漏的监控，大致原理如下：</p>
<p>目前最新版本仅用debugImplementation就可以实现内存泄漏监听。这是利用了ContentProVider进行初始化，在应用启动时回调他的oncreate方法。在oncreate方法里面进行他的多种watcher的安装。内部创建对于activity、fragmentAndViewModel、rootView、service的watcher，并依次进行install操作。</p>
<p>ContentProVider的oncreate在于application的oncreate（handleBindApplication），</p>
<p>晚于application的attachBaseContext。</p>
<p>先进性对应该回收对象的生命周期加入钩子。</p>
<ol>
<li>ActivityWatcher会在install操作中通过by noOpDelegate委托生成动态代理 application.registerActivityLifecycleCallbacks对其进行onActivityDestroyed监听，当activity调用ondestroyed时会进行内部ObjectWatcher的expectWeaklyReachable方法，检查五秒后是否被回收，未被回收则标记内存泄漏。</li>
<li>FragmentAndViewModelWatcher在开始与ActivityWatcher一样，不过是注册activity的onactivityCreated监听。在oncreate的时候对他的fragmentwatcher数组依次进行。</li>
<li>RootViewWatcher是使用Curtains的onRootViewsChangedListeners，在detached的时候验证</li>
<li>ServiceWatcher是通过反射activityThread拿到mservices，对activityThread中的handler的mcallback进行动态代理，在service真正destroy的时候进行验证</li>
</ol>
<p>ObjectWatcher进行对象的是否内存泄漏检查：</p>
<ol>
<li>先移除已被回收的对象</li>
<li>用UUID生成一个key，然后同观察对象、描述、引用队列等创建弱引用。并根据key将reference存入map里。</li>
<li>在默认5s延迟后再清理一遍，检测对象是否被回收</li>
<li>没有回收调用onObjectRetainedListener</li>
</ol>
<p>objectRetainedListener里面主要执行heapDumpTrigger的一些方法</p>
<ol>
<li>首先判断是否有异常持有的对象，有的话触发Gc操作，没有就返回</li>
<li>如果还有异常判断泄露数量是否达到dump</li>
<li>达到的话会进行dumpHeap</li>
<li>然后使用HeapAnalyzerService，启动shark分析</li>
<li>读取hprof内存快照文件</li>
<li>找到leakCanary标记的泄露对象的数量和弱引用包装的ids</li>
<li>找到gcRoot开始的路径</li>
</ol>
<h2 id="3-优化内存空间"><a href="#3-优化内存空间" class="headerlink" title="3.优化内存空间"></a>3.优化内存空间</h2><h3 id="1-对象引用"><a href="#1-对象引用" class="headerlink" title="1.对象引用"></a>1.对象引用</h3><ul>
<li>强引用：代码中普遍存在的，只要强引用还存在，垃圾收集器就不会回收掉被引用的对象。</li>
<li>软引用：SoftReference，用来描述还有用但是非必须的对象，当内存不足的时候会回收这类对象。</li>
<li>弱引用：WeakReference，用来描述非必须对象，弱引用的对象只能生存到下一次 GC 发生时，当 GC 发生时，无论内存是否足够，都会回收该对象。</li>
<li>虚引用：PhantomReference，一个对象是否有虚引用的存在，完全不会对其生存时间产生影响，也无法通过虚引用取得一个对象的引用，它存在的唯一目的是在这个对象被回收时可以收到一个系统通知。</li>
</ul>
<p>举个例子，单例工具类在使用一些activity或context，可以通过弱引用进行按相关操作。</p>
<h3 id="2-AutoBoxing"><a href="#2-AutoBoxing" class="headerlink" title="2.AutoBoxing"></a>2.AutoBoxing</h3><p>自动装箱的核心就是把基础数据类型转换成对应的复杂类型。在自动装箱转化时，都会产生一个新的对象，这样就会产生更多的内存和性能开销。如int只占4字节，而Integer对象有16字节，特别是HashMap这类容器，进行增、删、改、查操作时，都会产生大量的自动装箱操作。</p>
<p>在数据量千级以内的情况下</p>
<ul>
<li>如果 key 的类型已经确定为 int 类型，那么使用 SparseArray，因为它避免了自动装箱的过程，如果 key 为 long 类型，它还提供了一个 LongSparseArray 来确保 key 为 long 类型时的使用</li>
<li>如果 key 类型为其它的类型，则使用 ArrayMap。</li>
</ul>
<h3 id="3-LruCache"><a href="#3-LruCache" class="headerlink" title="3.LruCache"></a>3.LruCache</h3><p>最近最少使用缓存，使用强引用保存需要缓存的对象，它内部维护了一个由LinkedHashMap组成的双向列表，不支持线程安全，LruCache对它进行了封装，添加了线程安全操作。当其中的一个值被访问时，它被放到队列的尾部，当缓存将满时，队列头部的值（最近最少被访问的）被丢弃，之后可以被GC回收。</p>
<p>除了普通的get/set方法之外，还有sizeOf方法，它用来返回每个缓存对象的大小。此外，还有entryRemoved方法，当一个缓存对象被丢弃时调用的方法，当第一个参数为true：表明缓存对象是为了腾出空间而被清理。否则，表明缓存对象的entry是被remove移除或者被put覆盖。</p>
<p>注意：分配LruCache大小时应考虑应用剩余内存有多大。</p>
<h3 id="4-图片内存优化"><a href="#4-图片内存优化" class="headerlink" title="4.图片内存优化"></a>4.图片内存优化</h3><p>在Android默认情况下，当图片文件解码成位图时，会被处理成32bit/像素。红色、绿色、蓝色和透明通道各8bit，即使是没有透明通道的图片，如JEPG隔世是没有透明通道的，但然后会处理成32bit位图，这样分配的32bit中的8bit透明通道数据是没有任何用处的，这完全没有必要，并且在这些图片被屏幕渲染之前，它们首先要被作为纹理传送到GPU，这意味着每一张图片会同时占用CPU内存和GPU内存。下面，我总结了减少内存开销的几种常用方式，如下所示：</p>
<p>1、设置位图的规格：当显示小图片或对图片质量要求不高时可以考虑使用RGB_565，用户头像或圆角图片一般可以尝试ARGB_4444。通过设置inPreferredConfig参数来实现不同的位图规格，代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BitmapFactory.Options options = new BitmapFactory.Options();</span><br><span class="line">options.inPreferredConfig = Bitmap.Config.RGB_565;</span><br><span class="line">BitmapFactory.decodeStream(is, null, options);</span><br></pre></td></tr></table></figure>

<p>2、inSampleSize：位图功能对象中的inSampleSize属性实现了位图的缩放功能，代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BitampFactory.Options options = new BitmapFactory.Options();</span><br><span class="line">// 设置为4就是宽和高都变为原来1/4大小的图片</span><br><span class="line">options.inSampleSize = 4;</span><br><span class="line">BitmapFactory.decodeSream(is, null, options);</span><br></pre></td></tr></table></figure>

<p>3、inScaled，inDensity和inTargetDensity实现更细的缩放图片：当inScaled设置为true时，系统会按照现有的密度来划分目标密度，代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BitampFactory.Options options = new BitampFactory.Options();</span><br><span class="line">options.inScaled = true;</span><br><span class="line">options.inDensity = srcWidth;</span><br><span class="line">options.inTargetDensity = dstWidth;</span><br><span class="line">BitmapFactory.decodeStream(is, null, options);</span><br></pre></td></tr></table></figure>

<p>上述三种方案的缺点：使用了过多的算法，导致图片显示过程需要更多的时间开销，如果图片很多的话，就影响到图片的显示效果。最好的方案是结合这两个方法，达到最佳的性能结合，首先使用inSampleSize处理图片，转换为接近目标的2次幂，然后用inDensity和inTargetDensity生成最终想要的准确大小，因为inSampleSize会减少像素的数量，而基于输出密码的需要对像素重新过滤。但获取资源图片的大小，需要设置位图对象的inJustDecodeBounds值为true，然后继续解码图片文件，这样才能生产图片的宽高数据，并允许继续优化图片。总体的代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BitmapFactory.Options options = new BitampFactory.Options();</span><br><span class="line">options.inJustDecodeBounds = true;</span><br><span class="line">BitmapFactory.decodeStream(is, null, options);</span><br><span class="line">options.inScaled = true;</span><br><span class="line">options.inDensity = options.outWidth;</span><br><span class="line">options.inSampleSize = 4;</span><br><span class="line">Options.inTargetDensity = desWith * options.inSampleSize;</span><br><span class="line">options.inJustDecodeBounds = false;</span><br><span class="line">BitmapFactory.decodeStream(is, null, options);</span><br></pre></td></tr></table></figure>

<p>4、图片放置优化</p>
<p>只需要UI提供一套高分辨率的图，图片建议放在drawable-xxhdpi文件夹下，这样在低分辨率设备中图片的大小只是压缩，不会存在内存增大的情况。如若遇到不需缩放的文件，放在drawable-nodpi文件夹下。</p>
<p>5、在App可用内存过低时主动释放内存</p>
<p>在App退到后台内存紧张即将被Kill掉时选择重写 onTrimMemory/onLowMemory 方法去释放掉图片缓存、静态缓存来自保。</p>
<p>6、item被回收不可见时释放掉对图片的引用</p>
<ul>
<li><strong>ListView</strong> ：因此每次item被回收后再次利用都会重新绑定数据，只需在ImageView onDetachFromWindow的时候释放掉图片引用即可。</li>
<li><strong>RecyclerView</strong> ：因为被回收不可见时第一选择是放进mCacheView中，这里item被复用并不会只需bindViewHolder来重新绑定数据，只有被回收进mRecyclePool中后拿出来复用才会重新绑定数据，因此重写Recycler.Adapter中的onViewRecycled()方法来使item被回收进RecyclePool的时候去释放图片引用。</li>
</ul>
<p>7、避免创作不必要的对象</p>
<p>例如，我们可以在字符串拼接的时候使用StringBuffer，StringBuilder。</p>
<p>8、自定义View中的内存优化</p>
<p>例如，在onDraw方法里面不要执行对象的创建，一般来说，都应该在自定义View的构造器中创建对象。</p>
<p>9、其它的内存优化注意事项</p>
<p>除了上面的一些内存优化点之外，这里还有一些内存优化的点我们需要注意，如下所示：</p>
<ul>
<li>尽使用static final 优化成员变量。</li>
<li>使用增强型for循环语法。</li>
<li>在没有特殊原因的情况下，尽量使用基本数据类型来代替封装数据类型，int比Integer要更加有效，其它数据类型也是一样。</li>
<li>在合适的时候适当采用软引用和弱引用。</li>
<li>采用内存缓存和磁盘缓存。</li>
<li>尽量采用静态内部类，可避免潜在由于内部类导致的内存泄漏。</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
        <category>Android</category>
        <category>优化</category>
      </categories>
      <tags>
        <tag>Android优化</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题</title>
    <url>/2022/05/24/interview/</url>
    <content><![CDATA[<h1 id="1-Java面试题"><a href="#1-Java面试题" class="headerlink" title="1.Java面试题"></a>1.Java面试题</h1><h2 id="1-1Java基础"><a href="#1-1Java基础" class="headerlink" title="1.1Java基础"></a>1.1Java基础</h2><h3 id="①抽象类与接口区别"><a href="#①抽象类与接口区别" class="headerlink" title="①抽象类与接口区别"></a>①抽象类与接口区别</h3><ul>
<li>方法：抽象类可以提供方法的实现，接口中即jdk8以后添加default关键字才可以实现默认实现</li>
<li>参数：抽象类成员变量可以任意创建，接口只能是public static final修饰的变量</li>
<li>构造函数：接口不能拥有构造器，静态代码块、静态方法，抽象类可以</li>
<li>只可继承一个抽象类但是可以实现多个接口</li>
</ul>
<p>共同点是都不可直接实例化。</p>
<h3 id="②final、static、synchronized可以修饰什么-什么作用"><a href="#②final、static、synchronized可以修饰什么-什么作用" class="headerlink" title="②final、static、synchronized可以修饰什么 什么作用"></a>②final、static、synchronized可以修饰什么 什么作用</h3><p>final:</p>
<ul>
<li>类：说明该类功能已经全面了，不允许继承。String类。Interger</li>
<li>方法：该方法不可以被子类重写.final方法编译的时候已经静态绑定了</li>
<li>变量：变量不可变  成员变量或是局部变量修饰可以成为最终变量，配合静态static修饰变量称为常量</li>
</ul>
<p>static：</p>
<ul>
<li>代码块：类进行加载的时候会按顺序执行</li>
<li>方法：静态方法属于类的层面，调用的时候用类名.方法名直接调用</li>
<li>变量：静态变量，存在Java内存模型中的方法区</li>
<li>内部类：可以直接作为一个普通类使用，不需要先实例化一个外部类实例</li>
</ul>
<p>synchronized：</p>
<ul>
<li>修饰方法：方法为静态方法为类锁，反之为对象锁</li>
<li>修饰代码块：锁住的是类为类锁，反之为对象锁</li>
</ul>
<h3 id="③String、StringBuffer、StringBUilder"><a href="#③String、StringBuffer、StringBUilder" class="headerlink" title="③String、StringBuffer、StringBUilder"></a>③String、StringBuffer、StringBUilder</h3><p>String为字符串常量，如果要进行拼接+操作，会生成一个新的字符串重新赋予变量，连续拼接操作时会造成一些资源损耗还影响效率</p>
<p>StringBuilder是线程不安全的字符串拼接工具类，append</p>
<p>StringBuffer为线程安全的</p>
<h3 id="④equals-hashcode"><a href="#④equals-hashcode" class="headerlink" title="④equals == hashcode"></a>④equals == hashcode</h3><p>未重写equals等方法时与==一样，对比引用是否一致</p>
<p>一般equals与hashcode需要统一重写，保证equals为true hashcode必须为true  可反性</p>
<h3 id="⑤Error和Exception区别"><a href="#⑤Error和Exception区别" class="headerlink" title="⑤Error和Exception区别"></a>⑤Error和Exception区别</h3><p>Error为程序运行时不可预料的错误情况，发生时会直接杀死进程</p>
<p>Exception为运行中可预料到的异常情况，分为检查性异常与非检查型异常，检查性异常需要在编写代码时使用try catch捕获</p>
<p>使用throw抛出的是error</p>
<h3 id="⑥什么是反射机制"><a href="#⑥什么是反射机制" class="headerlink" title="⑥什么是反射机制"></a>⑥什么是反射机制</h3><p>java反射就是在程序运行过程中通过一些类或方法或是变量的信息对其进行获取操作</p>
<p>获取类信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">obj.getClass()</span><br><span class="line">类名.class</span><br><span class="line">Class.forName(&quot;包名+类名&quot;)</span><br></pre></td></tr></table></figure>

<p>构造方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Constuctor[] getConstructors()：获取类中所有被public修饰的构造器</span><br><span class="line"></span><br><span class="line">Constructor getConstructor(Class...&lt;?&gt; paramTypes)：根据参数类型获取类中某个构造器，该构造器必须被public修饰</span><br><span class="line"></span><br><span class="line">Constructor[] getDeclaredConstructors()：获取类中所有构造器</span><br><span class="line"></span><br><span class="line">Constructor getDeclaredConstructor(class...&lt;?&gt; paramTypes)：根据参数类型获取对应的构造器</span><br><span class="line"></span><br><span class="line">Class clazz = Class.forName(&quot;com.bean.SmallPineapple&quot;);</span><br><span class="line"></span><br><span class="line">Constructor constructor = clazz.getConstructor(String.class, int.class);</span><br><span class="line"></span><br><span class="line">constructor.setAccessible(true);</span><br><span class="line"></span><br><span class="line">SmallPineapple smallPineapple2 = (SmallPineapple) constructor.newInstance(&quot;小菠萝&quot;, 21);</span><br><span class="line"></span><br><span class="line">smallPineapple2.getInfo();</span><br></pre></td></tr></table></figure>

<p>变量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Field[] getFields()：获取类中所有被public、protected修饰的所有变量</span><br><span class="line"></span><br><span class="line">Field getField(String name)：根据变量名获取类中的一个变量，获取是被public和protected修饰的</span><br><span class="line"></span><br><span class="line">Field[] getDeclaredFields()：获取类中所有的变量，但无法获取继承下来的变量</span><br><span class="line"></span><br><span class="line">Field getDeclaredField(String name)：根据姓名获取类中的某个变量，无法获取继承下来的变量</span><br></pre></td></tr></table></figure>

<p>方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Method[] getMethods()：获取类中被public、protected修饰的所有方法</span><br><span class="line"></span><br><span class="line">Method getMethod(String name, Class...&lt;?&gt; paramTypes)：根据名字和参数类型获取对应方法，该方法必须被public、protected修饰</span><br><span class="line"></span><br><span class="line">Method[] getDeclaredMethods()：获取所有方法，但无法获取继承下来的方法</span><br><span class="line"></span><br><span class="line">Method getDeclaredMethod(String name, Class...&lt;?&gt; paramTypes)：根据名字和参数类型获取对应方法，无法获取继承下来的方法</span><br></pre></td></tr></table></figure>

<p>注解：只有@Retension为RUNTIME时才能通过反射获取该注解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Annotation[] getAnnotations()：获取该对象上的所有注解</span><br><span class="line"></span><br><span class="line">Annotation getAnnotation(Class annotaionClass)：传入注解类型，获取该对象上的特定一个注解</span><br><span class="line"></span><br><span class="line">Annotation[] getDeclaredAnnotations()：获取该对象上的显式标注的所有注解，无法获取继承下来的注解</span><br><span class="line"></span><br><span class="line">Annotation getDeclaredAnnotation(Class annotationClass)：根据注解类型，获取该对象上的特定一个注解，无法获取继承下来的注解</span><br></pre></td></tr></table></figure>

<h3 id="⑦IO流分几种"><a href="#⑦IO流分几种" class="headerlink" title="⑦IO流分几种"></a>⑦IO流分几种</h3><p>IO流分为字节流和字符流，与之对应的抽象类有inputstream、outputstream、reader、writer</p>
<p>字节流可以传递存储任何类型的数据，字符流只能处理字符、字符串，使用指定的字符集进行编码操作</p>
<p>BIO：同步阻塞式IO  NIO：同步非阻塞 AIO：NIO升级也叫NIO2，异步非阻塞</p>
<h3 id="⑧泛型类型擦除"><a href="#⑧泛型类型擦除" class="headerlink" title="⑧泛型类型擦除"></a>⑧泛型类型擦除</h3><p>类型擦除发生在编译过程中，所有泛型信息都会被擦除</p>
<h3 id="⑨注解的理解"><a href="#⑨注解的理解" class="headerlink" title="⑨注解的理解"></a>⑨注解的理解</h3><p>本质：做一个标识，通过这个标识对代码规范、变量值做一些修饰。主要划分为三类</p>
<table>
<thead>
<tr>
<th>Source</th>
<th align="left">仅仅存在在.java文件，编译成.class文件就消失了。作用为：让开发者按照注解的规范编写代码。例如：<a href="https://github.com/OverRide">@OverRide</a></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Class</td>
<td align="left">在前期编译期的流程中，会被处理成.class内容，与原生代码效率几乎相同。<br />作用为：自动生成.class文件，做一些辅助性工作。例如：ButterKnife、GreenDao、ARouter</td>
<td>效率和原生代码相当</td>
</tr>
<tr>
<td>Runtime</td>
<td align="left">编译成.class文件之后，依旧以注解的方式存在。而是在运行期生效。<br />作用为：在运行期，通过反射做一些辅助性工作。例如：xUtils</td>
<td>由于集中使用遍历+反射，因此效率较低。而且在9.0禁用反射</td>
</tr>
</tbody></table>
<h2 id="1-2-Java集合"><a href="#1-2-Java集合" class="headerlink" title="1.2 Java集合"></a>1.2 Java集合</h2><h3 id="①list、set、map"><a href="#①list、set、map" class="headerlink" title="①list、set、map"></a>①list、set、map</h3><p>Iterator是所有集合的总接口，Collection继承于Iterator。list有序可重复，set无序不可重复，map键值对，键唯一。</p>
<p>list、set继承自collection。ArrayList数组结构，存储地址连续、linkedList双向链表结构。</p>
<p>hashset哈希表实现，无序可放入null</p>
<p>treeset是二叉树红黑树结构实现的，自动排序不允许null值</p>
<p>hashmap hashtable concurrentHashMap、linkedhashmap</p>
<h2 id="1-3-Java多线程"><a href="#1-3-Java多线程" class="headerlink" title="1.3 Java多线程"></a>1.3 Java多线程</h2><h3 id="①-java-多线程的方式"><a href="#①-java-多线程的方式" class="headerlink" title="① java 多线程的方式"></a>① java 多线程的方式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 继承Thread，重写run方法，用start启动</span><br><span class="line">2. 自定义runnable，放入thread启动</span><br><span class="line">3.通过线程池、callable、future实现有返回结果的多线程</span><br></pre></td></tr></table></figure>

<h3 id="②-线程的状态"><a href="#②-线程的状态" class="headerlink" title="② 线程的状态"></a>② 线程的状态</h3><ul>
<li>new 创建状态</li>
<li>runnable 运行</li>
<li>blocked 阻塞</li>
<li>waiting 等待</li>
<li>timed_waiting 超时等待</li>
<li>end 终止</li>
</ul>
<h3 id="③-实现多线程中的同步"><a href="#③-实现多线程中的同步" class="headerlink" title="③ 实现多线程中的同步"></a>③ 实现多线程中的同步</h3><ul>
<li><p>volatile 简单逻辑可以实现 简单的 set get</p>
</li>
<li><p>synchronized</p>
</li>
<li><p>reentrantlock</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. Lock lock = new ReentrantLock();</span><br><span class="line">   try &#123;</span><br><span class="line">            todo.........</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">也可以尝试获取锁</span><br><span class="line">if (lock.tryLock(1, TimeUnit.SECONDS)) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">2.配合condition的await和signal模仿obj的wait、notify</span><br><span class="line">3.  ReadWriteLock rwlock = new ReentrantReadWriteLock();</span><br><span class="line">    Lock rlock = rwlock.readLock();</span><br><span class="line">    Lock wlock = rwlock.writeLock();</span><br></pre></td></tr></table></figure></li>
<li><p>cas   unsafe类</p>
</li>
<li><p>Object.wait/notify</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wait属于object类中的方法，调用后释放锁，将当前线程a放入该对象锁的等待池，线程b执行notify会通知等待池，使线程a从等待池进入阻塞队列等到线程b释放锁后线程a竞争锁继续执行。</span><br><span class="line">notifyall会把等待池里所有的线程唤醒去竞争</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="④-线程池"><a href="#④-线程池" class="headerlink" title="④ 线程池"></a>④ 线程池</h3><ul>
<li><p>常见线程池</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Executors.newFixedThreadPool 使用的是linkedblockingqueue  指定核心线程数</span><br><span class="line">Executors.newCachedThreadPool 使用的是SynchronousQueue</span><br><span class="line">Executors.newSingleThreadExecutor 使用的是LinkedBlokingQueue</span><br><span class="line">Executors.newScheduledThreadPool</span><br><span class="line"></span><br><span class="line">ThreadPoolExecutor  核心线程数 最大线程数 超时回收时间 时间单位 任务处理队列 线程工厂</span><br></pre></td></tr></table></figure>

<p>核心线程-》阻塞队列-》非核心线程-》handler拒绝任务提交</p>
</li>
<li><p>常见的任务处理阻塞队列<br>ArrayBlockingQueue 有界数组阻塞队列<br>LinkedBlockingQueue 无界链表阻塞队列<br>SynchronousQueue 无存储队列<br>PriorityBlockingQueue 优先级阻塞队列</p>
</li>
<li><p>shutdown 关闭线程池——等添加到线程池中的任务全部完成才退出<br>shutdownNow  关闭线程池并中断任务  调用Tread.interrupt中断任务 但线程无sleep、wait、condition、定时锁等是无法中断新城，有可能需要等所有线程执行完毕关闭</p>
</li>
</ul>
<h3 id="⑤-synchronized与volatile"><a href="#⑤-synchronized与volatile" class="headerlink" title="⑤ synchronized与volatile"></a>⑤ synchronized与volatile</h3><p>volatile：</p>
<ol>
<li>保证变量在不同线程进行操作的可见性</li>
<li>禁止指令重排<br>指令重排是指指令乱序执行，有时在条件允许情况下，为了避开获取一条指令所需的数据而造成的等待，会通过乱序执行提高效率。添加一个内存屏障，指令乱序时不能把后面的指令排序移到内存屏障之前</li>
</ol>
<p>synchronize：</p>
<p>偏向锁、轻量级锁。自旋锁、重量级锁</p>
<h3 id="⑥-死锁"><a href="#⑥-死锁" class="headerlink" title="⑥ 死锁"></a>⑥ 死锁</h3><p>当线程a持有独占锁1，并尝试去获取独占锁2的同时，线程b持有独占锁2，并尝试获取独占锁1，这时两个线程都出去获取对方的独占锁处于阻塞状态，产生了死锁。</p>
<ol>
<li>互斥条件：一个资源只能被一个线程使用 独占锁</li>
<li>请求与保持条件：一个线程因请求资源被阻塞，对已获得的资源保持不释放</li>
<li>不剥夺条件： 线程获得资源在未使用完之前，不能强行剥夺</li>
<li>循环等待：若干线程之间形成头尾相接的循环资源等待关系</li>
</ol>
<p>解决办法：</p>
<ol>
<li>加锁顺序控制 按照一定顺序加锁</li>
<li>加锁时限 线索尝试获取锁时加上时限，超时则放弃对锁的请求，并释放自己占有的锁</li>
<li>死锁检测 加锁时将线程与锁存在类似map中，每当有线程请求锁失败时可以判断是否有循环锁占有和请求的关系进行处理</li>
</ol>
<h3 id="⑦-线程、进程"><a href="#⑦-线程、进程" class="headerlink" title="⑦ 线程、进程"></a>⑦ 线程、进程</h3><p>一个程序至少有一个进程，一个进程至少有一个线程</p>
<ol>
<li>进程是资源分配最小单位，线城市程序执行的最小单位。</li>
<li>进程有自己独立的地址空间，每启动一个进程系统会为其分配地址空间。线程没有独立的地址空间，统一进程的线程共享进程的地址空间</li>
<li>进程之间资源独立，同一进程内线程共享本晋城资源</li>
<li>每个独立进程有一个运行入口，顺序执行队列和程序出口。线程不能独立执行，依存于程序进程中</li>
</ol>
<h3 id="⑧-ThreadLocal"><a href="#⑧-ThreadLocal" class="headerlink" title="⑧ ThreadLocal"></a>⑧ ThreadLocal</h3><ol>
<li>原理：<br>每一个tread内部维护了一个threadlocalmap，内部维护了一个数组，数组里面存储的数据是一个entry内部类，key为threadlocal的弱引用，value为我们要存储的数据的强引用。<br>set方法：从当前线程获取他的localthreadmap，根据hashcode与数组长度计算在数组中存储的位置，分为几个情况<br>如果以前在当前位置存储过，更新后返回，发生hash冲突依次向后寻找。返回<br>如果当前key为null，也就是被回收了，会先向前遍历直到entry为空，找到第一个该回收的位置，然后再向后遍历查找是否和当前key匹配的有的话进行位置交换及清理,返回<br>如果没有存储过就直接新建存储，进行清理并检查需不需要扩容；<br>在执行get操作时，从当前线程获取他的localthreadmap，根据threadlocal的hashcode与数组长度计算存储的数组位置，通过当前的threadlocal获取我们存储的值。</li>
<li>内存泄漏：因为value为强引用，threadlocal回收后未去回收他的value就会发生内存泄漏，不用时应该保证执行remove或保证与线程生命周期相同</li>
</ol>
<h2 id="1-4-Java内存"><a href="#1-4-Java内存" class="headerlink" title="1.4 Java内存"></a>1.4 Java内存</h2><h3 id="①-类的加载"><a href="#①-类的加载" class="headerlink" title="① 类的加载"></a>① 类的加载</h3><ul>
<li>android中有5个类加载器：ClassLoader（所有类加载器的抽象基类）、BootClassLoader（用于加在android系统的类，classloader的内部类，开发者无法调用）、BaseDexClassLoader（继承ClassLoader）、PathClassLoader（继承于BaseDexClassLoader，通常用于加载我们自己写的类含第三方库，但不局限于此）、DexClassLoader（继承于BaseDexClassLoader，通常用于执行动态加载，能够加在指定路径的apk、jar、zip、dex文件，因此很多热修复和插件化方案使用）</li>
<li>加载时使用双亲委派模式加载，先以递归方式向上级父加载器验证是否已经加载，若没被加载过在从最顶级加载器进行加载操作，加载失败逐级向下进行加载。保证类只会被加载一次。</li>
<li>加载（通过类的全限定名获取类的二进制字节流，将静态存储结构转化为方法区的运行数据结构，在内存中生成Class对象，作为这个类的各种数据的方位入口）-》<br>连接（1.验证——语法是否通过；2.准备——变量分配内存；3.解析——接口、字段和方法的符号引用转为直接引用）-》<br>初始化（对变量和一些代码块进行初始化及执行）</li>
</ul>
<h3 id="②-引用类型"><a href="#②-引用类型" class="headerlink" title="② 引用类型"></a>② 引用类型</h3><ol>
<li>强引用：垃圾回收器不会回收，及时内存空间不足，jvm宁愿outofmemoryerror程序异常终止也不随意回收强引用对象</li>
<li>软引用：如果一个对象只有软引用，内存够用的时候不会对其进行回收，当内存不足时hiuduiqijinxinghuishou，可以和引用队列联合使用</li>
<li>弱引用：如果一个对象只有弱引用，垃圾回收器检测到就会对其进行回收。由于垃圾回收器所在线程优先级很低不一定会快发现，可以和引用队列联合使用</li>
<li>虚引用：任何时候都可能被回收，主要用于跟踪对象呗垃圾回收器回收的活动。必须与ReferenceQueue联合使用</li>
</ol>
<h3 id="③-Java内存模型"><a href="#③-Java内存模型" class="headerlink" title="③ Java内存模型"></a>③ Java内存模型</h3><ol>
<li>堆  对象</li>
<li>栈  线程栈帧 线程私有</li>
<li>本地方发栈</li>
<li>方法区 加载的类信息、常量、静态变量、即时编译器编译后的代码</li>
<li>程序计数器</li>
</ol>
<h3 id="④-Java内存回收机制"><a href="#④-Java内存回收机制" class="headerlink" title="④ Java内存回收机制"></a>④ Java内存回收机制</h3><ul>
<li><p>回收检测有两种：<br>引用计数法：有对这个对象的引用+1，不再引用-1<br>可达性分析：以GCRoots对象为起点，从这个节点从上到下搜索，路径称为引用链，当一个对象没有任何引用链与GCRoots连接时，就说明当前对象不可达可以回收<br>GC Roots对象通常包括：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">虚拟机栈中引用的对象——栈帧中的本地变量表</span><br><span class="line">方法中类的静态属性引用的对象</span><br><span class="line">方法区常量引用的对象</span><br><span class="line">Native方法引用的对象</span><br></pre></td></tr></table></figure></li>
<li><p>回收算法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 标记清除：</span><br><span class="line">   扫描并标记存活目标，标记完成后再扫描未标记的对象对其进行回收。存活对象多时效率高</span><br><span class="line">但是会造成内存碎片。</span><br><span class="line">2. 标记整理：</span><br><span class="line">   在标记清除基础上，将存活的内存进行移动整理更新指针。适合对象存活率高的场景——老</span><br><span class="line">年代回收。</span><br><span class="line">3. 复制：</span><br><span class="line">   将内存分为大小相等两块，每次只是用一块。当内存使用完后，将存活对象复制到另一侧，</span><br><span class="line">再将该区域全部清除。适用于对象存活率低情况——新生代。</span><br><span class="line">4. 分代收集：</span><br><span class="line">   不同的对象生命周期不同，不同的生命周期的对象放置在堆中的不同区域，以不同的策略</span><br><span class="line">进行回收提高效率。新生代使用复制算法；老年代使用标记清除或标记整理。分代收集一般分</span><br><span class="line">为新生代，老年代和永久代。</span><br><span class="line">   新生代：所有新对象首先都放在新生代，按照8：1：1比例分为一个Eden区和两个survivor区。</span><br><span class="line">大部分对象在Eden区生成，回收时先将Eden存活对象复制到survivor0然后清空Eden，</span><br><span class="line">当这survivor0存放满，将Eden区域survivor0中存活的对象复制到survivor1中，</span><br><span class="line">清空Eden与survivor0，然后将survivor0与survivor1互换保证survivor1为空。</span><br><span class="line">当survivor1不足存放时就会将存活对象存放至老年代。若是老年代满了就会出发full GC，</span><br><span class="line">也就是新老年代都进行回收。新生代的GC叫做MinorGC发生频率高。</span><br><span class="line">   老年代： 内存大概是新生代的两倍，老年代中的对象存活时间长。</span><br><span class="line">   永久代： 主要存放静态文件，如java类、方法等。对垃圾回收没有显著影响，用来解决</span><br><span class="line">动态代理或是反射等等运行中新增的类的内存。</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="⑤-jvm、dalvik和art"><a href="#⑤-jvm、dalvik和art" class="headerlink" title="⑤ jvm、dalvik和art"></a>⑤ jvm、dalvik和art</h3><ul>
<li>jvm：java虚拟机，并不是某个特定虚拟机的实现，而是任何能运行java字节码的虚拟机实现</li>
<li>dalvik：是google创建的用于android的虚拟机，但其严格来说不算jvm，5.0被art替代<br>基于寄存器，jvm基于堆栈；有自己的字节码不是java字节码；jit即时编译</li>
<li>art：android run time。4.4-6.0采用安装时全部编译为机器码的方式实现，7.0开始默认不全部编译，采用解释执行+jit+空闲时间aot以改善安装耗时。<br>aot预编译在安装过程中，将所有字节码变异成机器码，运行时直接调用。</li>
</ul>
<h1 id="2-Kotlin"><a href="#2-Kotlin" class="headerlink" title="2 Kotlin"></a>2 Kotlin</h1><h2 id="2-1-kotlin语言特性"><a href="#2-1-kotlin语言特性" class="headerlink" title="2.1 kotlin语言特性"></a>2.1 kotlin语言特性</h2><h3 id="①-介绍kotlin其特性"><a href="#①-介绍kotlin其特性" class="headerlink" title="① 介绍kotlin其特性"></a>① 介绍kotlin其特性</h3><ul>
<li>能与java互相调用</li>
<li>减少样板代码</li>
<li>可将kotlin编译为无需虚拟机就可以运行的原生二进制文件</li>
<li>支持高阶函数</li>
<li>支持协程</li>
<li>语言层面解决空指针问题</li>
<li>对lambda表达式更好地支持</li>
</ul>
<h3 id="②-JvmOverloads作用"><a href="#②-JvmOverloads作用" class="headerlink" title="② @JvmOverloads作用"></a>② @JvmOverloads作用</h3><p>在有默认参数值的方法中使用@JvmOverloads注解会重载多个方法。</p>
<h3 id="③-kotlin中单例与java对比"><a href="#③-kotlin中单例与java对比" class="headerlink" title="③ kotlin中单例与java对比"></a>③ kotlin中单例与java对比</h3><ol>
<li><p>线程不安全饿汉式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kotlin：</span><br><span class="line">object Single&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">java：</span><br><span class="line">class Single &#123;</span><br><span class="line">    private static Single instance = new Single();</span><br><span class="line"></span><br><span class="line">    public static Single getInstance()&#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>线程不安全懒汉式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kotlin：</span><br><span class="line">class Single&#123;</span><br><span class="line">    companion object&#123;</span><br><span class="line">        val instance by lazy &#123; Single() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">java：</span><br><span class="line">class Single &#123;</span><br><span class="line">    private static Single instance;</span><br><span class="line"></span><br><span class="line">    public static Single getInstance()&#123;</span><br><span class="line">        if (instance == null)&#123;</span><br><span class="line">            instance = new Single();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>双重校验</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kotlin：</span><br><span class="line">class Single&#123;</span><br><span class="line">    companion object&#123;</span><br><span class="line">        val instance by lazy(LazyThreadSafetyMode.SYNCHRONIZED) &#123; Single() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">java:</span><br><span class="line">class Single &#123;</span><br><span class="line">    private volatile static Single instance;</span><br><span class="line"></span><br><span class="line">    public static Single getInstance()&#123;</span><br><span class="line">        if (instance == null)&#123;</span><br><span class="line">            synchronized (Single.class)&#123;</span><br><span class="line">                if (instance == null)&#123;</span><br><span class="line">                    instance = new Single();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>静态内部类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kotlin：</span><br><span class="line">class Single&#123;</span><br><span class="line">    companion object&#123;</span><br><span class="line">        val instance = SingleHolder.Single</span><br><span class="line">    &#125;</span><br><span class="line">    private object SingleHolder&#123;</span><br><span class="line">        val Single = Single()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">java：</span><br><span class="line">class Single &#123;</span><br><span class="line">    private static class SingleHolder&#123;</span><br><span class="line">        public static final Single holder = new Single();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Single getInstance()&#123;</span><br><span class="line">        return SingleHolder.holder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="④-dataClass"><a href="#④-dataClass" class="headerlink" title="④ dataClass"></a>④ dataClass</h3><p>会自动生成equals/hashCode方法、toString、componentN解构方法和copy方法</p>
<h3 id="⑤-with、run、also、apply、let"><a href="#⑤-with、run、also、apply、let" class="headerlink" title="⑤ with、run、also、apply、let"></a>⑤ with、run、also、apply、let</h3><ul>
<li>let、also、apply、let都是作为扩展函数，传入一个lambda表达式<br>let：返回值是最后一行或return的数据<br>also： 返回的是对象本身，this表示可省略<br>run：返回最后一行的值或表达式<br>apply：返回本身<br>let与also会将属性作为参数传入lambda中，所以使用属性需要用it表示，let返回lambda执行结果，also返回属性值<br>run与apply传入的lambda是带属性T的接受者对象的函数，run返回的是执行结果，apply是返回属性this</li>
<li>with 是传入两个参数，第一个是属性值，第二个是属性的扩展lambda函数并返回</li>
</ul>
<h3 id="⑥-Unit与Void区别"><a href="#⑥-Unit与Void区别" class="headerlink" title="⑥ Unit与Void区别"></a>⑥ Unit与Void区别</h3><p>Unit：Kotlin中Any的子类，作为返回类型时可省略</p>
<p>Void：java中无返回类型时使用，关键字，不可行略</p>
<p>nothing：一般形容无法继续执行，常常和抛出异常一起使用</p>
<h3 id="⑦-关键修饰符"><a href="#⑦-关键修饰符" class="headerlink" title="⑦ 关键修饰符"></a>⑦ 关键修饰符</h3><ol>
<li>中缀函数 infix 定义的函数必须只有一个参数，可省略.与参数括号</li>
<li>密封类 sealed 表示受限的类继承结构，本身是抽象类不可以实例化，必须和子类在同一个包中</li>
<li>init函数执行顺序： 主构造函数 &gt; init &gt; 次级构造函数</li>
<li>object 与 companion object 的区别** object 有两层语义：静态匿名内部类 + 单例对象 companion object 是伴生对象，一个类只能有一个，代表了类的静态成员（函数 / 属性）</li>
<li>inner 非静态内部类， kotlin内部类默认是静态内部类，如果要使用类中成员方法和属性需要加inner</li>
<li>inline 内联函数，表示将函数内容。如果我们是用lambda表达式作为参数，lambda在编译后转换为匿名类或是静态对象会造成额外开销。<br>noinline 当函数被inline标记，参数使用该标记不使用内联，不可return主函数<br>crossinline 允许内联函数里的函数类型参数可以被间接调用，但是不能在Lambda表达式中使用全局return返回</li>
</ol>
<h3 id="⑧-any与object区别"><a href="#⑧-any与object区别" class="headerlink" title="⑧ any与object区别"></a>⑧ any与object区别</h3><ul>
<li>相同：都是顶级父类</li>
<li>差异：any只声明toString/equeals/hashcode作为成员方法,没有wait、notify、clone、finalize等，属于兼容java平台的平台类型。</li>
</ul>
<h3 id="⑨-委托"><a href="#⑨-委托" class="headerlink" title="⑨ 委托"></a>⑨ 委托</h3><ul>
<li><p>Observable</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var name: String by Delegates.observable(初始值)&#123;prop,old,new -&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>自定义委托 ReadOnlyProperty、ReadWriteProperty、PropertyDelegateProvider</p>
</li>
<li><p>懒加载委托</p>
</li>
</ul>
<h2 id="2-2-协程"><a href="#2-2-协程" class="headerlink" title="2.2 协程"></a>2.2 协程</h2><h3 id="①-协程的使用"><a href="#①-协程的使用" class="headerlink" title="① 协程的使用"></a>① 协程的使用</h3><ul>
<li>协程通过CoroutineScope创建，启动方式有三种：1.runBlocking——启动一个新协程并阻塞调用他的线程，直到里面的代码执行完毕，返回最后一行；2.launch——启动一个协程不会阻塞调用线程，必须在协程作用域中才能调用，返回job；3.async——启动一个协程不会阻塞调用线程，必须在协程作用域中才能调用。返回Deferred（继承job）。</li>
<li>GlobalScope全局顶级协程，这个协程是在整个应用程序生命周期内运行的。使用launch、async。</li>
<li>suspend是协程关键字，代表挂起函数，只能在suspend方法或者在协程中调用。</li>
</ul>
<h1 id="3-android"><a href="#3-android" class="headerlink" title="3 android"></a>3 android</h1><h2 id="3-1-各框架原理"><a href="#3-1-各框架原理" class="headerlink" title="3.1 各框架原理"></a>3.1 各框架原理</h2><h3 id="①-LeakCanary"><a href="#①-LeakCanary" class="headerlink" title="① LeakCanary"></a>① LeakCanary</h3><p>目前最新版本仅用debugImplementation就可以实现内存泄漏监听。这是利用了ContentProVider进行初始化，在应用启动时回调他的oncreate方法。在oncreate方法里面进行他的多种watcher的安装。内部创建对于activity、fragmentAndViewModel、rootView、service的watcher，并依次进行install操作。</p>
<p>ContentProVider的oncreate在于application的oncreate（handleBindApplication），</p>
<p>晚于application的attachBaseContext。</p>
<p>先进性对应该回收对象的生命周期加入钩子。</p>
<ol>
<li>ActivityWatcher会在install操作中通过by noOpDelegate委托生成动态代理 application.registerActivityLifecycleCallbacks对其进行onActivityDestroyed监听，当activity调用ondestroyed时会进行内部ObjectWatcher的expectWeaklyReachable方法，检查五秒后是否被回收，未被回收则标记内存泄漏。</li>
<li>FragmentAndViewModelWatcher在开始与ActivityWatcher一样，不过是注册activity的onactivityCreated监听。在oncreate的时候对他的fragmentwatcher数组依次进行。</li>
<li>RootViewWatcher是使用Curtains的onRootViewsChangedListeners，在detached的时候验证</li>
<li>ServiceWatcher是通过反射activityThread拿到mservices，对activityThread中的handler的mcallback进行动态代理，在service真正destroy的时候进行验证</li>
</ol>
<p>ObjectWatcher进行对象的是否内存泄漏检查：</p>
<ol>
<li>先移除已被回收的对象</li>
<li>用UUID生成一个key，然后同观察对象、描述、引用队列等创建弱引用。并根据key将reference存入map里。</li>
<li>在默认5s延迟后再清理一遍，检测对象是否被回收</li>
<li>没有回收调用onObjectRetainedListener</li>
</ol>
<p>objectRetainedListener里面主要执行heapDumpTrigger的一些方法</p>
<ol>
<li>首先判断是否有异常持有的对象，有的话触发Gc操作，没有就返回</li>
<li>如果还有异常判断泄露数量是否达到dump</li>
<li>达到的话会进行dumpHeap</li>
<li>然后使用HeapAnalyzerService，启动shark分析</li>
<li>读取hprof内存快照文件</li>
<li>找到leakCanary标记的泄露对象的数量和弱引用包装的ids</li>
<li>找到gcRoot开始的路径</li>
</ol>
<h3 id="②-Eventbus"><a href="#②-Eventbus" class="headerlink" title="② Eventbus"></a>② Eventbus</h3><p>EventBus.getdefault方法其实是一个双重校验的单例方法，内部涉及几个map</p>
<p>首先是一个method_Cache的concurrentHashmap，他的key是类信息，value是解析过的方法数组</p>
<p>subscriptionsByEventType，key是event的类信息，value是存储subscription的copyOnWriteArrayList</p>
<p>在我们register的时候。</p>
<ol>
<li>首先获取注册类信息，并对其进行方法的提取</li>
<li>在method＿cache查找是否有解析过的缓存</li>
<li>没有的话，先创建一个findState维护类的相关数据。</li>
<li>通过反射拿到类里面的所有方法，通过方法的修饰符（必须public，非static，非abstract）和参数数目进行过滤，再将过滤出的方法进行自己的注解比对</li>
<li>完全符合会根据注解获取threadmode等等和其他信息整理成一个subscibermethod，存放在findstate的监听方法数组里</li>
<li>在检查父类有没有相应的方法需要添加，当获取所有方法完毕后，对这些方法依次进行subscriber操作</li>
<li>将注册对象与subscibermethod封装成一个subscription，然后再存在subscriptionsByEventType的当前eventType的数组里</li>
<li></li>
</ol>
<p>在我们post事件时</p>
<ol>
<li>将事件存放在threadlocal里的postingState的eventQueue里</li>
<li>取出第一个event，获取他的类信息，在eventTypesCache里面找有没有event数组，里面是当前事件及其基类的class对象和接口基类的class对象</li>
<li>然后对这些事件进行分发处理，在subscriptionsByEventType找到对应的subscription数组。</li>
<li>将每一个subscription与当前事件、当前线程是否主线程共同传入postToSubscription方法中</li>
<li>通过当前线程是否是主线程和subscription中的threadMode进行判断，决定是否切换线程，不需要切换直接反射调用。</li>
<li>需要切换线程时，再将subscription与event封装一起发送到指定线程执行。</li>
</ol>
<h3 id="③-retrofit"><a href="#③-retrofit" class="headerlink" title="③ retrofit"></a>③ retrofit</h3><ol>
<li>首先在retrofit记录下配置的calladapterFactories和converterFactories</li>
<li>在执行retrofit.create的时候，先验证apiService的合法性，再进行动态代理实现具体方法。</li>
<li>object或是platform的方法直接执行</li>
<li>RequestFactory的parseAnnotations方法解析method中的注解</li>
<li>然后传递给HttpServiceMethod创建OKhttpCall并进行adapt操作</li>
<li>根据我们的callAdapterFactory包装成我们指定的call对象，默认是retrofitCall</li>
<li>创建request对象使用okhttp进行请求，拿到结果后通过配置的converterFactory解析成我们指定的数据格式</li>
</ol>
<h3 id="④-okhttp"><a href="#④-okhttp" class="headerlink" title="④ okhttp"></a>④ okhttp</h3><ul>
<li>大概流程：</li>
</ul>
<ol>
<li>通过建造者模式构建okhttp和request</li>
<li>okhttpClient通过newCall发起请求</li>
<li>通过分发器维护请求队列和线程池，完成接口调配</li>
<li>通过五大默认拦截器完成请求重试，缓存处理，建立连接等一些列操作</li>
<li>得到结果完成回调</li>
</ol>
<ul>
<li>okhttp分发器工作流程：</li>
</ul>
<p>分发器主要维护请求队列与线程池</p>
<p>同步任务请求不需要线程池，只需按照加入队列的顺序请求</p>
<p>异步请求则要进行判断正在执行的任务未超过最大限制64，同时同一host的请求不超过5个，添加在正在执行队列，同时提交给线程池。否则加入到等待队列。每个任务完成后都会调用分发器的finished方法，在等待队列中取出等待队列的任务继续执行。</p>
<ul>
<li>拦截器</li>
</ul>
<p>执行getResponseWithInterceptorChain方法是使用了责任链模式，依次进行重试与重定向拦截器、桥接拦截器、缓存拦截器、连接拦截器、自定义拦截器和请求拦截器。分别负责重试重定向、处理header、缓存、连接池等</p>
<h3 id="⑤-Android与js交互"><a href="#⑤-Android与js交互" class="headerlink" title="⑤ Android与js交互"></a>⑤ Android与js交互</h3><p>js调用Android</p>
<ul>
<li>创建一个处理交互的方法类，在方法上面添加@JavascriptInterface，再执行webview.addJavascriptinterface()进行映射。</li>
<li>通过 <code>WebViewClient</code>的shouldoverrideUrl()进行链接拦截处理</li>
<li>通过 <code>WebChromeClient</code>的onjsaler confirm prompt</li>
</ul>
<p>android 调用 js</p>
<ul>
<li>webview.loadurl（“<code>javascript:</code>”）</li>
<li><code>WebView.evaluateJavascript(</code>)</li>
</ul>
<p>webview优化</p>
<p>1.独立进程，android：process 退出system。exit</p>
<p>2.预加载 建立webview维护类。使用mutablecontextwrapper 优先传入applicationcontext，后面可以通过重新设置basecontext更改绑定特定的activity</p>
<h3 id="⑥-其他"><a href="#⑥-其他" class="headerlink" title="⑥ 其他"></a>⑥ 其他</h3><p>多渠道包：productflavor配置不同applicationid，将公有库统一维护，各自业务使用风味名+implement进行引用，一些第三方库的一些秘钥使用manifestplaceholder进行维护</p>
<p>intentservice是继承service来创建工作线程，内部原理是在oncreate的时候创建一个handlerthread和他的servicehandler，在onstartcommand里面会点用onstart进行message的发送，在连续进行任务时可以按顺序进行处理。在任务都处理完成之后会自动结束。</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
</search>
